<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Allen&#39;s Blog</title>
  
  <subtitle>Just writing.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chuyao.github.io/"/>
  <updated>2021-05-26T05:06:13.965Z</updated>
  <id>https://chuyao.github.io/</id>
  
  <author>
    <name>Allen Shi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OrangePi-PCH3安卓系统定制</title>
    <link href="https://chuyao.github.io/2018/01/07/orangepi-pch3-system-customization/"/>
    <id>https://chuyao.github.io/2018/01/07/orangepi-pch3-system-customization/</id>
    <published>2018-01-07T07:09:45.000Z</published>
    <updated>2021-05-26T05:06:13.965Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、USB调试开放"><a href="#一、USB调试开放" class="headerlink" title="一、USB调试开放"></a>一、USB调试开放</h4><p>1、修改USB0配置 /lichee/tools/pack/chips/sun8iw7p1/configs/dolphin-p1/sys_config.fex</p><p>[usbc0]<br>usb_used                = 1<br>usb_port_type         = 0    // 0:device only; 1:host only; 2:OTG，默认是1<br>usb_detect_type     = 0</p><p>2、重复lichee编译<br>3、pack</p><h4 id="二、网络调试开放"><a href="#二、网络调试开放" class="headerlink" title="二、网络调试开放"></a>二、网络调试开放</h4><p>android/device/softwinner/dophin-common/init.sun8i.rc添加<br>on boot<br>setprop service.adb.tcp.port 5555<br>stop adbd<br>start adbd</p><h4 id="三、精简系统应用"><a href="#三、精简系统应用" class="headerlink" title="三、精简系统应用"></a>三、精简系统应用</h4><p>1、android/vendor/fvd/fvd.mk(对应的特殊版本定制的应用)修改<br>      android/build/target/product/tvd_base.mk(基础版本应用)<br>      PRODUCT_PACKAGE += \<br>2、android/vendor/fvd/packages/<br>      检查各项目下Android.mk文件中的LOCAL_OVERRIDES_PACKAGES值是否覆盖了某个应用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、USB调试开放&quot;&gt;&lt;a href=&quot;#一、USB调试开放&quot; class=&quot;headerlink&quot; title=&quot;一、USB调试开放&quot;&gt;&lt;/a&gt;一、USB调试开放&lt;/h4&gt;&lt;p&gt;1、修改USB0配置 /lichee/tools/pack/chips/sun8iw
      
    
    </summary>
    
      <category term="Tech" scheme="https://chuyao.github.io/categories/Tech/"/>
    
    
      <category term="Android" scheme="https://chuyao.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>OrangePi-PCH3安卓源码编译</title>
    <link href="https://chuyao.github.io/2018/01/07/orangepi-pch3-source-compile/"/>
    <id>https://chuyao.github.io/2018/01/07/orangepi-pch3-source-compile/</id>
    <published>2018-01-07T07:09:12.000Z</published>
    <updated>2021-05-26T05:06:13.964Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、源码下载"><a href="#一、源码下载" class="headerlink" title="一、源码下载"></a>一、源码下载</h4><p><a href="http://www.orangepi.cn/downloadresourcescn/orangepipc/oragepipc_e3edd0dd47da54c0b8f7aa2230.html" target="_blank" rel="noopener">官方源码</a><br>下载的源码文件是分块的压缩包，需要合并再解压<br>linux环境合并解压<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat xxx_1 xx_2 &gt; xx.tar.gz</span><br></pre></td></tr></table></figure></p><p>archive菜单直接解压xx.tar.gz</p><h4 id="二、编译环境准备-以ubuntu1604为例"><a href="#二、编译环境准备-以ubuntu1604为例" class="headerlink" title="二、编译环境准备(以ubuntu1604为例)"></a>二、编译环境准备(以ubuntu1604为例)</h4><p>1、python2.7.3<br>2、GNU Make 3.81-3.82(ubuntu1604自带make版本4.1，需要重新安装)<br>下载<a href="http://mirrors.ustc.edu.cn/gnu/make/" target="_blank" rel="noopener">3.81版本make</a>，解压后得到deb包<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get remove make</span><br><span class="line">$ sudo dpkg -i xxx.deb</span><br></pre></td></tr></table></figure></p><p>3、JDK安装，只支持jdk1.6<br>4、平台支持软件安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git gnupg flex bison gperf build-essential zip curl libc6-dev libncurses5-dev:i386 x11proto-core-dev libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-glx:i386 libgl1-mesa-dev g++-multilib mingw32 tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386</span><br><span class="line">$ sudo ln -s /usr/lib/i386-linux-gnu/mesa/libGL.so.1 /usr/lib/i386-linux-gnu/libGL.so</span><br><span class="line">$ sudo dpkg-reconfigure dash</span><br><span class="line">$ sudo apt-get install gawk</span><br><span class="line">$ sudo apt-get install u-boot-tools</span><br><span class="line">$ sudo apt-get install fakeroot</span><br></pre></td></tr></table></figure></p><p>5、lichee编译(kernel)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> lichee</span><br><span class="line">$ ./build.sh lunch</span><br></pre></td></tr></table></figure></p><p>选择sun8iw7p1-android-dolphin<br>6、源码编译<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> android</span><br><span class="line">$ <span class="built_in">source</span> ./build/envsetup.sh</span><br><span class="line">$ lunch dolphin_fvd_p1-eng</span><br><span class="line">$ extract-bsp</span><br><span class="line">$ make -j2</span><br><span class="line">$ pack</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、源码下载&quot;&gt;&lt;a href=&quot;#一、源码下载&quot; class=&quot;headerlink&quot; title=&quot;一、源码下载&quot;&gt;&lt;/a&gt;一、源码下载&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;http://www.orangepi.cn/downloadresourcescn/or
      
    
    </summary>
    
      <category term="Tech" scheme="https://chuyao.github.io/categories/Tech/"/>
    
    
      <category term="Android" scheme="https://chuyao.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>在U盘上建立git仓库，移动的“私有云”</title>
    <link href="https://chuyao.github.io/2017/11/17/git-usb/"/>
    <id>https://chuyao.github.io/2017/11/17/git-usb/</id>
    <published>2017-11-17T06:35:23.000Z</published>
    <updated>2021-05-26T05:06:13.937Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>Git作为版本管理工具，其功能之强大，已无需赘述。一般情况下，我们接触到的git都指远程操作，与远程git服务器协作，完成版本迭代管理。如果没有服务器，是否也能使用git呢？当然可以，这期文章，让我们一起来把git和我们的代码搬到U盘上，建立一个真正属于自己而又移动的“私有云”。</p><h4 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h4><p>1、安装好的git环境，参见<a href="https://git-scm.com/" target="_blank" rel="noopener">Git官网</a>。<br>2、U盘一个，大小容量没有严格要求。</p><h4 id="三、命令行操作"><a href="#三、命令行操作" class="headerlink" title="三、命令行操作"></a>三、命令行操作</h4><p>1、在U盘上创建空仓库test.git(我的U盘盘符在PC端是I盘)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /I</span><br><span class="line">$ mkdir <span class="built_in">test</span></span><br><span class="line">$ <span class="built_in">cd</span> <span class="built_in">test</span></span><br><span class="line">$ git init --bare</span><br></pre></td></tr></table></figure><p>得到如下显示即表明git仓库创建成功<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Initialized empty Git repository <span class="keyword">in</span> I:/<span class="built_in">test</span>/</span><br></pre></td></tr></table></figure></p><p>2、现有git工程与U盘仓库关联(在git工程根目录下执行)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add usb /i/<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>3、版本管理，仓库有了，剩下就是推送和拉取文件了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push usb master</span><br><span class="line">$ git pull usb master</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h4&gt;&lt;p&gt;Git作为版本管理工具，其功能之强大，已无需赘述。一般情况下，我们接触到的git都指远程操作，与远程git服务器协作，完成版
      
    
    </summary>
    
      <category term="Tech" scheme="https://chuyao.github.io/categories/Tech/"/>
    
    
      <category term="Git" scheme="https://chuyao.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>OpenSSL基础教程二：RSA命令行加解密</title>
    <link href="https://chuyao.github.io/2017/09/07/openssl-2-rsa-command-operation/"/>
    <id>https://chuyao.github.io/2017/09/07/openssl-2-rsa-command-operation/</id>
    <published>2017-09-07T08:44:07.000Z</published>
    <updated>2021-05-26T05:06:13.963Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>&#8195;&#8195;在上一篇教程中，讲解了如何生成RSA密钥，提到了密钥长度设定对加密过程的影响问题。本篇文章，让我们来使用RSA密钥对数据进行加解密，并验证一下密钥长度对加密的影响，依赖于OpenSSL强大而丰富的命令行命令，可以简洁清晰的实现这两个目标。为了方便演示讲解，本文中使用的密钥是默认的512比特长度。</p><h4 id="二、公钥加密"><a href="#二、公钥加密" class="headerlink" title="二、公钥加密"></a>二、公钥加密</h4><p>&#8195;&#8195;公钥私钥是成对出现，一个加密，另一个解密。当然，数据也可以由私钥加密，由公钥解密。所谓公钥，即对外公开的，公钥由私钥生成而来，知道私钥即可知道公钥，在RSA的设计设想中，这是一条单向线，因此，要自己保护好私钥，把公钥公开，一般情况下，公钥持有者用公钥把明文数据加密成密文，将密文发送给私钥持有者，私钥持有者用私钥对密文解密得到明文数据，完成加解密流程。本文的演示流程也将按照这个来进行。<br>&#8195;&#8195;新建一个空白文档文件 <em>data.txt</em>，用文本编辑器编辑文本内容，输入 <em>Hello RSA</em> 并保存，作为我们的明文数据。<br>&#8195;&#8195;公钥加密，命令行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ openssl rsautl -encrypt -<span class="keyword">in</span> data.txt -inkey public.key -pubin -out data_en.txt</span><br></pre></td></tr></table></figure></p><ul><li>意思是：RSA工具(rsautl)加密操作(-encrypt)，导入(-in)明文数据data.txt，导入密钥(-inkey)，声明密钥是公钥(-pubin)，加密后密文输出保存到(-out)data_en.txt文件中。</li><li>加密时，OpenSSL会默认导入的密钥是私钥，所以，公钥加密需要加上 <em>-pubin</em> 参数以表明加密操作是以公钥进行，私钥加密时因为是默认私钥，所以不需要加相关参数。一定要确认使用的是哪个密钥加密，如果使用公钥而又不加 <em>-pubin</em> 参数，命令行会报错，加密也会失败。<a id="more"></a>&#8195;&#8195;命令行无错误提示，即表明加密成功，来看看密文文件 <em>data_en.txt</em> 的内容：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat data_en.txt</span><br><span class="line">�W��</span><br><span class="line">����u+�E�=J�w������ �n(W˯f�g<span class="string">'n�&lt;grHY����w�=jI�)M�.i</span></span><br></pre></td></tr></table></figure></li></ul><p>&#8195;&#8195;我当然看不懂了！<br>&#8195;&#8195;同样的加密操作我们再来一次，看看两次加密得到的密文是否一样。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ openssl rsautl -encrypt -<span class="keyword">in</span> data.txt -inkey public.key -pubin -out data_en.txt</span><br><span class="line">$ cat data_en.txt</span><br><span class="line">��ީ�q�%EM����vBe)P~�����ϙ��ZԱ[ޥb�9~����Ө|�=�R��c�[��</span><br></pre></td></tr></table></figure></p><p>&#8195;&#8195;我当然依然看不懂了，但明显，两次加密生成密文是不一样的，这也是RSA加密算法的重点优势体现，密文是动态的，安全性得到了提升。</p><h4 id="三、私钥解密"><a href="#三、私钥解密" class="headerlink" title="三、私钥解密"></a>三、私钥解密</h4><p>&#8195;&#8195;前面我们已经得到了密文数据文件 <em>data_en.txt</em>，我们来使用私钥进行解密还原。命令行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ openssl rsautl -decrypt -<span class="keyword">in</span> data_en.txt -inkey private.key -out data_de.txt</span><br></pre></td></tr></table></figure></p><ul><li>意思应该已经很好理解了：RSA工具解密操作(-decrypt)，导入密文数据文件data_en.txt，导入私钥private.key，默认密钥为私钥，解密后明文数据输出保存到 data_de.txt文件中。</li></ul><p>&#8195;&#8195;命令行无错误提示，即表明解密成功，来看看明文文件 <em>data_de.txt</em> 的内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat data_de.txt</span><br><span class="line">Hello RSA</span><br></pre></td></tr></table></figure></p><p>&#8195;&#8195;好了，是不是很有成就感？！</p><h4 id="四、密钥长度问题验证"><a href="#四、密钥长度问题验证" class="headerlink" title="四、密钥长度问题验证"></a>四、密钥长度问题验证</h4><p>&#8195;&#8195;先来看看我们经过加解密过程得到的三个文件的大小<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ll data.txt</span><br><span class="line">-rw-r--r-- 1 user 197121 10 Sep   7 15:20 data.txt</span><br><span class="line">$ ll data_en.txt</span><br><span class="line">-rw-r--r-- 1 user 197121 64 Sep   7 15:20 data_en.txt</span><br><span class="line">$ ll data_de.txt</span><br><span class="line">-rw-r--r-- 1 user 197121 10 Sep   7 15:21 data_de.txt</span><br></pre></td></tr></table></figure></p><p>&#8195;&#8195;data.txt是10个字节，data_en.txt是64个字节，还原的的data_de.txt是10个字节，符合我们下面进行的公式计算。<br>&#8195;&#8195;以512比特长度的密钥用公式计算，<em>512/8 = 64</em>，即经过这个密钥加密后的密文长度(亦或大小)固定是64个字节，可加密的最大明文数据大小为 <em>512/8 - 11 = 53</em> 个字节，一个英文字母即一个字节。我们来验证一下，编辑data.txt，把 <em>Hello RSA</em> 替换为 <em>abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</em>，保存后可以查看data.txt的大小，刚好53个字节。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ll data.txt</span><br><span class="line">-rw-r--r-- 1 user 197121 53 Sep   7 15:32 data.txt</span><br></pre></td></tr></table></figure></p><p>&#8195;&#8195;对这个文件执行公钥加密操作，可以看到，是成功的，我们再来编辑这个文件，随意插入一个字母，保存，data.txt大小将变为54字节，再进行一次公钥加密操作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ openssl rsautl -encrypt -<span class="keyword">in</span> data.txt -inkey public.key -pubin -out data_en.txt</span><br><span class="line">RSA operation error</span><br><span class="line">139970621331096:error:0406D06E:rsa routines:RSA_padding_add_PKCS1_type_2:data too large <span class="keyword">for</span> key size:rsa_pk1.c:153:</span><br></pre></td></tr></table></figure></p><p>&#8195;&#8195;可见，加密失败，因为明文数据长度超过53字节了。要想对这么长的数据进行RSA加密，我们需要一个更大容量的密钥，留个作业，动手去生成一个1024比特长度密钥，来加密一个54字节长度的明文数据，验证一下，可以加深你对这个问题的理解。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h4&gt;&lt;p&gt;&amp;#8195;&amp;#8195;在上一篇教程中，讲解了如何生成RSA密钥，提到了密钥长度设定对加密过程的影响问题。本篇文章，让我们来使用RSA密钥对数据进行加解密，并验证一下密钥长度对加密的影响，依赖于OpenSSL强大而丰富的命令行命令，可以简洁清晰的实现这两个目标。为了方便演示讲解，本文中使用的密钥是默认的512比特长度。&lt;/p&gt;
&lt;h4 id=&quot;二、公钥加密&quot;&gt;&lt;a href=&quot;#二、公钥加密&quot; class=&quot;headerlink&quot; title=&quot;二、公钥加密&quot;&gt;&lt;/a&gt;二、公钥加密&lt;/h4&gt;&lt;p&gt;&amp;#8195;&amp;#8195;公钥私钥是成对出现，一个加密，另一个解密。当然，数据也可以由私钥加密，由公钥解密。所谓公钥，即对外公开的，公钥由私钥生成而来，知道私钥即可知道公钥，在RSA的设计设想中，这是一条单向线，因此，要自己保护好私钥，把公钥公开，一般情况下，公钥持有者用公钥把明文数据加密成密文，将密文发送给私钥持有者，私钥持有者用私钥对密文解密得到明文数据，完成加解密流程。本文的演示流程也将按照这个来进行。&lt;br&gt;&amp;#8195;&amp;#8195;新建一个空白文档文件 &lt;em&gt;data.txt&lt;/em&gt;，用文本编辑器编辑文本内容，输入 &lt;em&gt;Hello RSA&lt;/em&gt; 并保存，作为我们的明文数据。&lt;br&gt;&amp;#8195;&amp;#8195;公钥加密，命令行命令&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ openssl rsautl -encrypt -&lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; data.txt -inkey public.key -pubin -out data_en.txt&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;意思是：RSA工具(rsautl)加密操作(-encrypt)，导入(-in)明文数据data.txt，导入密钥(-inkey)，声明密钥是公钥(-pubin)，加密后密文输出保存到(-out)data_en.txt文件中。&lt;/li&gt;
&lt;li&gt;加密时，OpenSSL会默认导入的密钥是私钥，所以，公钥加密需要加上 &lt;em&gt;-pubin&lt;/em&gt; 参数以表明加密操作是以公钥进行，私钥加密时因为是默认私钥，所以不需要加相关参数。一定要确认使用的是哪个密钥加密，如果使用公钥而又不加 &lt;em&gt;-pubin&lt;/em&gt; 参数，命令行会报错，加密也会失败。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://chuyao.github.io/categories/Tech/"/>
    
    
      <category term="OpenSSL" scheme="https://chuyao.github.io/tags/OpenSSL/"/>
    
  </entry>
  
  <entry>
    <title>OpenSSL基础教程一：RSA加解密算法密钥</title>
    <link href="https://chuyao.github.io/2017/09/07/openssl-1-rsa-key/"/>
    <id>https://chuyao.github.io/2017/09/07/openssl-1-rsa-key/</id>
    <published>2017-09-06T17:15:21.000Z</published>
    <updated>2021-05-26T05:06:13.962Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>&#8195;&#8195;1、关于OpenSSL的历史及应用领域，这里不作过多阐述，它是一个开源的安全套接字层密码库，由此你可以大致知道它的用处，想更多的了解，请访问<a href="https://www.openssl.org" target="_blank" rel="noopener">OpenSSL官方网站</a>及<a href="https://github.com/openssl/openssl" target="_blank" rel="noopener">OpenSSL开源代码库</a>。这里，主要讲解一下OpenSSL在RSA加密情景下的应用，如何生成RSA算法密钥及密钥的相关知识。<br>&#8195;&#8195;2、RSA，即非对称加解密，加解密原理推荐参考<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener">RSA算法原理（一）</a>及其系列文章。<br>&#8195;&#8195;3、OpenSSL作为知名的开源软件包，广泛被各大开源系统收录作为系统级软件包，比如主流版本的<a href="https://www.ubuntu.com" target="_blank" rel="noopener">Ubuntu</a>、<a href="https://www.centos.org" target="_blank" rel="noopener">CentOS</a>等Linux系操作系统，及闭源的<a href="https://www.apple.com/macos/sierra/" target="_blank" rel="noopener">MacOS</a>(即苹果操作系统，Unix系)，本文涉及的命令行操作均在Linux环境下进行，所以，基础的Linux操作系统知识是必须的。打开命令行工具，执行 <em>openssl version -a</em> 命令，可检测你的操作系统是否具备OpenSSL的执行环境。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ openssl version -a</span><br><span class="line"></span><br><span class="line">OpenSSL 0.9.8zh 14 Jan 2016</span><br><span class="line">built on: Jan 23 2017</span><br><span class="line">platform: darwin64-x86_64-llvm</span><br><span class="line">options:  bn(64,64) md2(int) rc4(ptr,char) des(idx,cisc,16,int) blowfish(idx) </span><br><span class="line">compiler: -arch x86_64 -fmessage-length=0 -pipe -Wno-trigraphs -fpascal-strings -fasm-blocks -O3 -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -DL_ENDIAN -DMD32_REG_T=int -DOPENSSL_NO_IDEA -DOPENSSL_PIC -DOPENSSL_THREADS -DZLIB -mmacosx-version-min=10.6</span><br><span class="line">OPENSSLDIR: <span class="string">"/System/Library/OpenSSL"</span></span><br></pre></td></tr></table></figure></p><p>&#8195;&#8195;以上显示即正常。</p><h4 id="二、OpenSSL生成RSA密钥对"><a href="#二、OpenSSL生成RSA密钥对" class="headerlink" title="二、OpenSSL生成RSA密钥对"></a>二、OpenSSL生成RSA密钥对</h4><h5 id="私钥的生成"><a href="#私钥的生成" class="headerlink" title="私钥的生成"></a>私钥的生成</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ openssl genrsa -out private.key</span><br><span class="line"></span><br><span class="line">Generating RSA private key, 512 bit long modulus</span><br><span class="line">.......++++++++++++</span><br><span class="line">.....++++++++++++</span><br><span class="line">e is 65537 (0x10001)</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;<em>openssl genrsa -out private.key</em> 这条命令的意思是：生成一个RSA算法私钥(genrsa)，保存到(-out)名为private.key的文件中。<br>&#8195;&#8195;这是最基本的生成RSA密钥的命令，其中，密钥保存的文件名可自定义，不限后缀，可以指定文件路径，如 <em>~/Desktop/private.key</em> 当然，这个命令还可以加上一些可选参数，如：<a id="more"></a></p><h6 id="openssl-genrsa-aes128-out-private-key-2048"><a href="#openssl-genrsa-aes128-out-private-key-2048" class="headerlink" title="openssl genrsa -aes128 -out private.key 2048"></a><em>openssl genrsa -aes128 -out private.key 2048</em></h6><ul><li><em>-aes128</em>，将私钥以AES-128算法保护，另有-aes129，-aes256</li><li><em>2048</em>，指定私钥长度为2048比特，默认是512比特，但512比特长度在现今技术环境下已不够安全，在被攻击的情况下，这个长度的密钥容易被黑客推算还原，可以使用512的整数倍值，1024，2048，4096等，推荐使用2048，这个长度的密钥已经相对安全可靠了。关于这个长度，还涉及到明文的长度问题，后面再作说明。</li></ul><p>&#8195;&#8195;让我们看看密钥的内容，其实是一堆文本字符串。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat private.key</span><br><span class="line"></span><br><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">MIIBOwIBAAJBALY3hztE11iplu8kIGOixQ9j7fueLEtp4nyIw3RivuSkI5ao7NS9</span><br><span class="line">P78TsH7H6LGJnlN2Ss/FU8BHWKLHwhB/wRECAwEAAQJBALMu+55+3bzkV/Yl8mvI</span><br><span class="line">Hjw6KkYqjqhCIWQRIRMMH2e5kDDstwrNl2/bKA/wqN6blfpENZ7l7IPV/+sJRgBq</span><br><span class="line">irkCIQDaPYuBix+iXO3mueO+FUtjX6M/d8sY44af7M+N7pltvwIhANW+Z8n5QNAC</span><br><span class="line">QOVE4mpYWK8AFQx9wYoSP/zU+w04iCUvAiEAthiiPZ3y8Euv6VNztpgYBju3f+6Z</span><br><span class="line">lRPLsccrS5cpiAsCIBbSzBZfDTKo6vEQV/TvFhkpsxWwX/g0VqzSuTQCM1d1AiA/</span><br><span class="line">O3uwoR4AWrZ5wehhXNNi8yk4l5J8AUpxPVVMkeXYqA==</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure></p><p>&#8195;&#8195;而其实作为密钥，它所包含的信息远比这一串字符串多得多。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">$ openssl rsa -text -<span class="keyword">in</span> private.key</span><br><span class="line"></span><br><span class="line">Private-Key: (512 bit)</span><br><span class="line">modulus:</span><br><span class="line">    00:b6:37:87:3b:44:d7:58:a9:96:ef:24:20:63:a2:</span><br><span class="line">    c5:0f:63:ed:fb:9e:2c:4b:69:e2:7c:88:c3:74:62:</span><br><span class="line">    be:e4:a4:23:96:a8:ec:d4:bd:3f:bf:13:b0:7e:c7:</span><br><span class="line">    e8:b1:89:9e:53:76:4a:cf:c5:53:c0:47:58:a2:c7:</span><br><span class="line">    c2:10:7f:c1:11</span><br><span class="line">publicExponent: 65537 (0x10001)</span><br><span class="line">privateExponent:</span><br><span class="line">    00:b3:2e:fb:9e:7e:dd:bc:e4:57:f6:25:f2:6b:c8:</span><br><span class="line">    1e:3c:3a:2a:46:2a:8e:a8:42:21:64:11:21:13:0c:</span><br><span class="line">    1f:67:b9:90:30:ec:b7:0a:<span class="built_in">cd</span>:97:6f:db:28:0f:f0:</span><br><span class="line">    a8:de:9b:95:fa:44:35:9e:e5:ec:83:d5:ff:eb:09:</span><br><span class="line">    46:00:6a:8a:b9</span><br><span class="line">prime1:</span><br><span class="line">    00:da:3d:8b:81:8b:1f:a2:5c:ed:e6:b9:e3:be:15:</span><br><span class="line">    4b:63:5f:a3:3f:77:cb:18:e3:86:9f:ec:cf:8d:ee:</span><br><span class="line">    99:6d:bf</span><br><span class="line">prime2:</span><br><span class="line">    00:d5:be:67:c9:f9:40:d0:02:40:e5:44:e2:6a:58:</span><br><span class="line">    58:af:00:15:0c:7d:c1:8a:12:3f:<span class="built_in">fc</span>:d4:fb:0d:38:</span><br><span class="line">    88:25:2f</span><br><span class="line">exponent1:</span><br><span class="line">    00:b6:18:a2:3d:9d:f2:f0:4b:af:e9:53:73:b6:98:</span><br><span class="line">    18:06:3b:b7:7f:ee:99:95:13:cb:b1:c7:2b:4b:97:</span><br><span class="line">    29:88:0b</span><br><span class="line">exponent2:</span><br><span class="line">    16:d2:cc:16:5f:0d:32:a8:ea:f1:10:57:f4:ef:16:</span><br><span class="line">    19:29:b3:15:b0:5f:f8:34:56:ac:d2:b9:34:02:33:</span><br><span class="line">    57:75</span><br><span class="line">coefficient:</span><br><span class="line">    3f:3b:7b:b0:a1:1e:00:5a:b6:79:c1:e8:61:5c:d3:</span><br><span class="line">    62:f3:29:38:97:92:7c:01:4a:71:3d:55:4c:91:e5:</span><br><span class="line">    d8:a8</span><br><span class="line">writing RSA key</span><br><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">MIIBOwIBAAJBALY3hztE11iplu8kIGOixQ9j7fueLEtp4nyIw3RivuSkI5ao7NS9</span><br><span class="line">P78TsH7H6LGJnlN2Ss/FU8BHWKLHwhB/wRECAwEAAQJBALMu+55+3bzkV/Yl8mvI</span><br><span class="line">Hjw6KkYqjqhCIWQRIRMMH2e5kDDstwrNl2/bKA/wqN6blfpENZ7l7IPV/+sJRgBq</span><br><span class="line">irkCIQDaPYuBix+iXO3mueO+FUtjX6M/d8sY44af7M+N7pltvwIhANW+Z8n5QNAC</span><br><span class="line">QOVE4mpYWK8AFQx9wYoSP/zU+w04iCUvAiEAthiiPZ3y8Euv6VNztpgYBju3f+6Z</span><br><span class="line">lRPLsccrS5cpiAsCIBbSzBZfDTKo6vEQV/TvFhkpsxWwX/g0VqzSuTQCM1d1AiA/</span><br><span class="line">O3uwoR4AWrZ5wehhXNNi8yk4l5J8AUpxPVVMkeXYqA==</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure></p><p>&#8195;&#8195;这才是它的真实面目，如果你接触过其它加密算法，应该对<em>modulus</em>、<em>exponent</em>不会感到陌生。</p><h5 id="公钥的生成"><a href="#公钥的生成" class="headerlink" title="公钥的生成"></a>公钥的生成</h5><h6 id="RSA算法密钥总是成对出现，先有私钥，再用私钥生成公钥"><a href="#RSA算法密钥总是成对出现，先有私钥，再用私钥生成公钥" class="headerlink" title="RSA算法密钥总是成对出现，先有私钥，再用私钥生成公钥"></a><em>RSA算法密钥总是成对出现，先有私钥，再用私钥生成公钥</em></h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ openssl rsa -<span class="keyword">in</span> private.key -pubout -out public.key</span><br><span class="line"></span><br><span class="line">writing RSA key</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;<em>openssl rsa -in private.key -pubout -out public.key</em> 这条命令的意思是：指定由(-in)私钥private.key生成公钥(-pubout)，并保存到名为public.key的文件中，参数<em>-in</em>及<em>-pubout</em>是必须的，而<em>-out</em>则跟私钥生成时的意义相同。<br>&#8195;&#8195;来看一下公钥的内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat public.key</span><br><span class="line"></span><br><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBALY3hztE11iplu8kIGOixQ9j7fueLEtp</span><br><span class="line">4nyIw3RivuSkI5ao7NS9P78TsH7H6LGJnlN2Ss/FU8BHWKLHwhB/wRECAwEAAQ==</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure></p><p>&#8195;&#8195;至此，我们已经完整的获取了一对RSA算法密钥，可以使用它们对数据进行加解密了。<br>&#8195;&#8195;回到之前生成私钥时提到的私钥长度的问题。在RSA算法中，对于一个已经生成的私钥来说，它的长度决定了密文的长度，比如，1024参数生成的密钥加密一段明文数据后，得到的密文长度换算为字节长度是 <em>1024/8 = 128</em>，形象一点，是128个英文字母的长度，这是固定的，也就是说，无论你的明文数据长度是多少，用这个密钥加密生成的密文总是也是最大有128个字节那么长，这是由算法本身决定的。显然，当明文数据超过128个字节时，使用这个密钥加密，只有前128字节的数据被加密了，其余的会被舍弃，这种情况下，加密后的密文是无法解密还原为之前的明文的，算法会报错。实际上，RSA算法规定密文需要11字节冗余，因此，最大可加密明文长度应该是 <em>1024/8 - 11 = 117</em>，即，明文不能超过117字节。所以，在使用RSA算法时，你需要评估一下你的明文数据，测量明文数据长度，留出冗余度，再决定你需要多长的密钥，从而生成正确的满足需求的密钥对。<br>&#8195;&#8195;可以意料到，因为算法的复杂，RSA加解密的开销代价是很大的，加解密的耗时，会随着密钥长度的增长及明文长度增长而比例增长，因此，RSA算法更适合用于微量数据的加解密。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h4&gt;&lt;p&gt;&amp;#8195;&amp;#8195;1、关于OpenSSL的历史及应用领域，这里不作过多阐述，它是一个开源的安全套接字层密码库，由此你可以大致知道它的用处，想更多的了解，请访问&lt;a href=&quot;https://www.openssl.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OpenSSL官方网站&lt;/a&gt;及&lt;a href=&quot;https://github.com/openssl/openssl&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OpenSSL开源代码库&lt;/a&gt;。这里，主要讲解一下OpenSSL在RSA加密情景下的应用，如何生成RSA算法密钥及密钥的相关知识。&lt;br&gt;&amp;#8195;&amp;#8195;2、RSA，即非对称加解密，加解密原理推荐参考&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RSA算法原理（一）&lt;/a&gt;及其系列文章。&lt;br&gt;&amp;#8195;&amp;#8195;3、OpenSSL作为知名的开源软件包，广泛被各大开源系统收录作为系统级软件包，比如主流版本的&lt;a href=&quot;https://www.ubuntu.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ubuntu&lt;/a&gt;、&lt;a href=&quot;https://www.centos.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CentOS&lt;/a&gt;等Linux系操作系统，及闭源的&lt;a href=&quot;https://www.apple.com/macos/sierra/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MacOS&lt;/a&gt;(即苹果操作系统，Unix系)，本文涉及的命令行操作均在Linux环境下进行，所以，基础的Linux操作系统知识是必须的。打开命令行工具，执行 &lt;em&gt;openssl version -a&lt;/em&gt; 命令，可检测你的操作系统是否具备OpenSSL的执行环境。&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ openssl version -a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OpenSSL 0.9.8zh 14 Jan 2016&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;built on: Jan 23 2017&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;platform: darwin64-x86_64-llvm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;options:  bn(64,64) md2(int) rc4(ptr,char) des(idx,cisc,16,int) blowfish(idx) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;compiler: -arch x86_64 -fmessage-length=0 -pipe -Wno-trigraphs -fpascal-strings -fasm-blocks -O3 -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -DL_ENDIAN -DMD32_REG_T=int -DOPENSSL_NO_IDEA -DOPENSSL_PIC -DOPENSSL_THREADS -DZLIB -mmacosx-version-min=10.6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OPENSSLDIR: &lt;span class=&quot;string&quot;&gt;&quot;/System/Library/OpenSSL&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;#8195;&amp;#8195;以上显示即正常。&lt;/p&gt;
&lt;h4 id=&quot;二、OpenSSL生成RSA密钥对&quot;&gt;&lt;a href=&quot;#二、OpenSSL生成RSA密钥对&quot; class=&quot;headerlink&quot; title=&quot;二、OpenSSL生成RSA密钥对&quot;&gt;&lt;/a&gt;二、OpenSSL生成RSA密钥对&lt;/h4&gt;&lt;h5 id=&quot;私钥的生成&quot;&gt;&lt;a href=&quot;#私钥的生成&quot; class=&quot;headerlink&quot; title=&quot;私钥的生成&quot;&gt;&lt;/a&gt;私钥的生成&lt;/h5&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ openssl genrsa -out private.key&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Generating RSA private key, 512 bit long modulus&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.......++++++++++++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.....++++++++++++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;e is 65537 (0x10001)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&amp;#8195;&amp;#8195;&lt;em&gt;openssl genrsa -out private.key&lt;/em&gt; 这条命令的意思是：生成一个RSA算法私钥(genrsa)，保存到(-out)名为private.key的文件中。&lt;br&gt;&amp;#8195;&amp;#8195;这是最基本的生成RSA密钥的命令，其中，密钥保存的文件名可自定义，不限后缀，可以指定文件路径，如 &lt;em&gt;~/Desktop/private.key&lt;/em&gt; 当然，这个命令还可以加上一些可选参数，如：&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://chuyao.github.io/categories/Tech/"/>
    
    
      <category term="OpenSSL" scheme="https://chuyao.github.io/tags/OpenSSL/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin基础教程第四章：Kotlin类 (Android)</title>
    <link href="https://chuyao.github.io/2017/08/18/kotlin-android-tutorial-4/"/>
    <id>https://chuyao.github.io/2017/08/18/kotlin-android-tutorial-4/</id>
    <published>2017-08-18T07:54:36.000Z</published>
    <updated>2021-05-26T05:06:13.956Z</updated>
    
    <content type="html"><![CDATA[<p>&#8195;&#8195;本篇文章，让我们来学习Kotlin类及其属性。<br>&#8195;&#8195;欢迎你回头学习之前的文章，可以让你更好的继续学习Kotlin知识。</p><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>&#8195;&#8195;如果你曾学习过任何一门“面向对象编程”语言，你将对类及其属性很熟悉。</p><blockquote><p>一个类可以比作模板或蓝图，用来创建不同的对象，并定义对象的属性及行为。</p></blockquote><p>在Java中，要创建一个类，需要定义一个类，定义它的构造器、它的<em>getter</em>和<em>setter</em>方法，通过这些方式，简单的给成员变量赋值或取出它们的值。这些乏味的工作不会出现在Kotlin中。</p><h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a><em>Java</em></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a><em>Kotlin</em></h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String)</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;怎么样？是不是很简洁明了？Kotlin一行代码即可实现Java需要九行代码才能实现的功能。写这样的代码，岂能不感叹“<em>人生苦短，快用Kotlin！</em>”<br>&#8195;&#8195;你应该已经注意到了，类的前边没有<em>public</em>关键字，是因为在Kotlin中，所有的类默认都是<em>public</em>的，所以可以丢掉了。</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>&#8195;&#8195;在定义的类中，一般含有一些成员变量和方法，通常，这些数据都是私有的，不能直接访问，普遍的做法是通过创建<em>getter</em>方法来获取这些数据。在所有的“<em>面向对象编程</em>”语言中，这些做法的结合，通常称为“<em>封装</em>”。在Kotlin中，赋值和取值方法有很大的不同。<br>&#8195;&#8195;声明一个属性有两种方式，如果是以 <em>val</em> 声明，则这个属性是只读的，而如果是以 <em>var</em> 声明，则这个属性是可变的，你可以在任何时刻修改它。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>(</span><br><span class="line">    <span class="keyword">val</span> name : String,  <span class="comment">// 只读，产生成员变量及getter</span></span><br><span class="line">    <span class="keyword">var</span> age : <span class="built_in">Int</span>   <span class="comment">// 可变的，产生成员变量，getter及setter</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>&#8195;&#8195;任何时候，你想声明一个属性，就会产生一个成员变量，一个getter或setter(取决于如何声明)。下边的例子，你可以看到如何创建一个Person实例对象，并访问它的属性。<a id="more"></a><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = Person(<span class="string">"Allen Shi"</span>, <span class="number">18</span>)</span><br><span class="line">println(person.name)    <span class="comment">//输出-&gt; Allen Shi</span></span><br><span class="line">println(person.age)     <span class="comment">//输出-&gt; 18</span></span><br></pre></td></tr></table></figure></p><h4 id="自定义访问器"><a href="#自定义访问器" class="headerlink" title="自定义访问器"></a>自定义访问器</h4><p>&#8195;&#8195;设想一下，你定义了一个属性并想要通过自己的逻辑来返回结果。通过自定义访问器即可实现。在本文的例子中，我们想要知道某个人是否成年，我们不需要在类中存储任何附加的属性就可简单的实现。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(</span><br><span class="line">    <span class="keyword">val</span> name : String,</span><br><span class="line">    <span class="keyword">var</span> age : <span class="built_in">Int</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">val</span> isAdult : <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> age &gt; <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&#8195;&#8195;在这个方法里，我们定义了一个isAdult属性，通过检查age值来决定isAdult的返回值。注意，你需要将方法用val关键字来声明，否则会报错。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = Person(<span class="string">"Allen"</span>, <span class="number">20</span>)</span><br><span class="line">println(person1.isAdult)    <span class="comment">//输出-&gt; true</span></span><br><span class="line"><span class="keyword">var</span> person2 = Person(<span class="string">"Eva"</span>, <span class="number">18</span>)</span><br><span class="line">println(person2.isAdult)    <span class="comment">//输出-&gt; false</span></span><br></pre></td></tr></table></figure></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&#8195;&#8195;本文，我们学习了如何声明一个类及其属性，收获了在Kotlin中的getter和setter属性，现在，你也可以声明自己的属性方法，使用自己的逻辑来返回你需要的结果了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;#8195;&amp;#8195;本篇文章，让我们来学习Kotlin类及其属性。&lt;br&gt;&amp;#8195;&amp;#8195;欢迎你回头学习之前的文章，可以让你更好的继续学习Kotlin知识。&lt;/p&gt;
&lt;h4 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h4&gt;&lt;p&gt;&amp;#8195;&amp;#8195;如果你曾学习过任何一门“面向对象编程”语言，你将对类及其属性很熟悉。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个类可以比作模板或蓝图，用来创建不同的对象，并定义对象的属性及行为。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Java中，要创建一个类，需要定义一个类，定义它的构造器、它的&lt;em&gt;getter&lt;/em&gt;和&lt;em&gt;setter&lt;/em&gt;方法，通过这些方式，简单的给成员变量赋值或取出它们的值。这些乏味的工作不会出现在Kotlin中。&lt;/p&gt;
&lt;h5 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;&lt;em&gt;Java&lt;/em&gt;&lt;/h5&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;Kotlin&quot;&gt;&lt;a href=&quot;#Kotlin&quot; class=&quot;headerlink&quot; title=&quot;Kotlin&quot;&gt;&lt;/a&gt;&lt;em&gt;Kotlin&lt;/em&gt;&lt;/h5&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; name: String)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&amp;#8195;&amp;#8195;怎么样？是不是很简洁明了？Kotlin一行代码即可实现Java需要九行代码才能实现的功能。写这样的代码，岂能不感叹“&lt;em&gt;人生苦短，快用Kotlin！&lt;/em&gt;”&lt;br&gt;&amp;#8195;&amp;#8195;你应该已经注意到了，类的前边没有&lt;em&gt;public&lt;/em&gt;关键字，是因为在Kotlin中，所有的类默认都是&lt;em&gt;public&lt;/em&gt;的，所以可以丢掉了。&lt;/p&gt;
&lt;h4 id=&quot;属性&quot;&gt;&lt;a href=&quot;#属性&quot; class=&quot;headerlink&quot; title=&quot;属性&quot;&gt;&lt;/a&gt;属性&lt;/h4&gt;&lt;p&gt;&amp;#8195;&amp;#8195;在定义的类中，一般含有一些成员变量和方法，通常，这些数据都是私有的，不能直接访问，普遍的做法是通过创建&lt;em&gt;getter&lt;/em&gt;方法来获取这些数据。在所有的“&lt;em&gt;面向对象编程&lt;/em&gt;”语言中，这些做法的结合，通常称为“&lt;em&gt;封装&lt;/em&gt;”。在Kotlin中，赋值和取值方法有很大的不同。&lt;br&gt;&amp;#8195;&amp;#8195;声明一个属性有两种方式，如果是以 &lt;em&gt;val&lt;/em&gt; 声明，则这个属性是只读的，而如果是以 &lt;em&gt;var&lt;/em&gt; 声明，则这个属性是可变的，你可以在任何时刻修改它。&lt;br&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt; &lt;/span&gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; name : String,  &lt;span class=&quot;comment&quot;&gt;// 只读，产生成员变量及getter&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; age : &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;// 可变的，产生成员变量，getter及setter&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;#8195;&amp;#8195;任何时候，你想声明一个属性，就会产生一个成员变量，一个getter或setter(取决于如何声明)。下边的例子，你可以看到如何创建一个Person实例对象，并访问它的属性。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://chuyao.github.io/categories/Tech/"/>
    
    
      <category term="Android" scheme="https://chuyao.github.io/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://chuyao.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin基础教程第三章：Kotlin运算符 (Android)</title>
    <link href="https://chuyao.github.io/2017/08/15/kotlin-android-tutorial-3/"/>
    <id>https://chuyao.github.io/2017/08/15/kotlin-android-tutorial-3/</id>
    <published>2017-08-15T13:55:47.000Z</published>
    <updated>2021-05-26T05:06:13.951Z</updated>
    
    <content type="html"><![CDATA[<p>&#8195;&#8195;在这篇文章里，你将学习到运算符知识及它们在Kotlin中的运用。<br>&#8195;&#8195;但是在进入正题之前，我已经在之前的文章里解释了如何在Android Studio中配置Kotlin开发环境及Kotlin语言变量。如果你还有不清楚的地方，请先阅读之前的文章再来进行这篇文章知识的学习。</p><h5 id="第一章：在Android-Studio中配置Kotlin环境"><a href="#第一章：在Android-Studio中配置Kotlin环境" class="headerlink" title="第一章：在Android Studio中配置Kotlin环境"></a><a href="https://chuyao.github.io/2017/08/10/kotlin-android-tutorial-1/">第一章：在Android Studio中配置Kotlin环境</a></h5><h5 id="第二章：Kotlin变量-Android"><a href="#第二章：Kotlin变量-Android" class="headerlink" title="第二章：Kotlin变量 (Android)"></a><a href="https://chuyao.github.io/2017/08/13/kotlin-android-tutorial-2/">第二章：Kotlin变量 (Android)</a></h5><h4 id="二进制运算符"><a href="#二进制运算符" class="headerlink" title="二进制运算符"></a>二进制运算符</h4><p>&#8195;&#8195;在运算符的使用上，Kotlin是一门强大的语言。在其它计算机语言如Java中，是不允许用户在非原始类型数据间使用算术运算符的。你想对ArrayList使用“<em>+</em>”，是不允许的。但Kotlin可以，Kotlin提供了二进制运算符相对应的可重载的方法名。</p><table><thead><tr><th style="text-align:left">表达式</th><th style="text-align:left">方法</th></tr></thead><tbody><tr><td style="text-align:left">a + b</td><td style="text-align:left">a.plus(b)</td></tr><tr><td style="text-align:left">a - b</td><td style="text-align:left">a.minus(b)</td></tr><tr><td style="text-align:left">a * b</td><td style="text-align:left">a.times(b)</td></tr><tr><td style="text-align:left">a / b</td><td style="text-align:left">a.div(b)</td></tr><tr><td style="text-align:left">a % b</td><td style="text-align:left">a.rem(b), a.mod(b)(过时的)</td></tr><tr><td style="text-align:left">a..b</td><td style="text-align:left">a.rangeTo(b)</td></tr></tbody></table><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>&#8195;&#8195;如果你正在使用的Kotlin是1.1版本，请使用<em>rem()</em>方法，<em>mod()</em>方法从1.1版本开始已经过时了。<br>&#8195;&#8195;如你所见，每一个二进制运算符都有一个方法让它更易读。当你想对自定义的类使用运算方法时，你会感觉很容易使用以及重载。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>(<span class="keyword">val</span> count: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(increment: <span class="type">Int</span>)</span></span>: Test &#123;</span><br><span class="line">        <span class="keyword">return</span> Test(count + increment)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">times</span><span class="params">(multiply: <span class="type">Int</span>)</span></span>: Test &#123;</span><br><span class="line">        <span class="keyword">return</span> Test(count + multiply)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> test = Test(<span class="number">10</span>)</span><br><span class="line">println(test + <span class="number">10</span>)  <span class="comment">//输出 -&gt; Test(count=20)</span></span><br><span class="line">println(test * <span class="number">2</span>)   <span class="comment">//输出 -&gt; Test(count=12)</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>阴吹斯汀！</p><h4 id="一元运算"><a href="#一元运算" class="headerlink" title="一元运算"></a>一元运算</h4><p>&#8195;&#8195;在Java或其它语言中，你一定很熟悉一元运算符。在Kotlin中，只要你愿意，你也可以在自定义类中使用和重载它们。</p><table><thead><tr><th style="text-align:left">表达式</th><th style="text-align:left">方法</th></tr></thead><tbody><tr><td style="text-align:left">+a</td><td style="text-align:left">a.unaryPlus()</td></tr><tr><td style="text-align:left">-a</td><td style="text-align:left">a.unaryMinus()</td></tr><tr><td style="text-align:left">!a</td><td style="text-align:left">a.not()</td></tr></tbody></table><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>(<span class="keyword">val</span> count: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Test.<span class="title">unaryMinus</span><span class="params">()</span></span> = Test(-count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> test = Test(<span class="number">10</span>)</span><br><span class="line">println(-test)       <span class="comment">//输出 -&gt; Test(count=-10)</span></span><br></pre></td></tr></table></figure><p>&#8195;&#8195;可以看到，一元方法是没有参数的。当<em>-test</em>被调用时，它会检查<em>unaryMinus()</em>是否已经被重载，如果是，就会返回适当的结果。</p><h4 id="自增和自减"><a href="#自增和自减" class="headerlink" title="自增和自减"></a>自增和自减</h4><p>&#8195;&#8195;没有这个运算符，你的循环是不完整的。是的，<em>++</em>和<em>–</em>是非常有用的运算符，接着看表和重载方法</p><table><thead><tr><th style="text-align:left">表达式</th><th style="text-align:left">方法</th></tr></thead><tbody><tr><td style="text-align:left">a++</td><td style="text-align:left">a.inc()</td></tr><tr><td style="text-align:left">a–</td><td style="text-align:left">a.dec()</td></tr></tbody></table><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> BigDecimal.<span class="title">inc</span><span class="params">()</span></span> = <span class="keyword">this</span> + BigDecimal.ONE</span><br><span class="line"><span class="keyword">var</span> bigDec = BigDecimal.ZERO</span><br><span class="line">println(bigDec++)  <span class="comment">//输出 -&gt; 0</span></span><br><span class="line">println(++bigDec)  <span class="comment">//输出 -&gt; 2</span></span><br></pre></td></tr></table></figure><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>&#8195;&#8195;使用赋值运算符，你通过操作二进制运算符来改变对象的值。当使用简单的二进制运算符时，对象的值不会被改变。</p><table><thead><tr><th style="text-align:left">表达式</th><th style="text-align:left">方法</th></tr></thead><tbody><tr><td style="text-align:left">a += b</td><td style="text-align:left">a.plusAssign(b)</td></tr><tr><td style="text-align:left">a -= b</td><td style="text-align:left">a.minusAssign(b)</td></tr><tr><td style="text-align:left">a *= b</td><td style="text-align:left">a.timesAssign(b)</td></tr><tr><td style="text-align:left">a /= b</td><td style="text-align:left">a.divAssign(b)</td></tr><tr><td style="text-align:left">a %= b</td><td style="text-align:left">a.modAssign(b)</td></tr></tbody></table><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mutableCollection = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> iterable = listOf(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">mutableCollection.plusAssign(iterable)</span><br><span class="line">println(mutableCollection)  <span class="comment">//输出 -&gt; [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">mutableCollection += <span class="number">6</span></span><br><span class="line">println(mutableCollection)  <span class="comment">//输出 -&gt; [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><h4 id="其它运算符"><a href="#其它运算符" class="headerlink" title="其它运算符"></a>其它运算符</h4><p>&#8195;&#8195;还有许多其它的运算符可以使用</p><table><thead><tr><th style="text-align:left">表达式</th><th style="text-align:left">方法</th></tr></thead><tbody><tr><td style="text-align:left">a in b</td><td style="text-align:left">b.contains(a)</td></tr><tr><td style="text-align:left">a !in b</td><td style="text-align:left">!b.contains(a)</td></tr><tr><td style="text-align:left">a[i]</td><td style="text-align:left">a.get(i)</td></tr><tr><td style="text-align:left">a[i, j]</td><td style="text-align:left">a.get(i, j)</td></tr><tr><td style="text-align:left">a[i_1, …, i_n]</td><td style="text-align:left">a.get(i_1, …, i_n)</td></tr><tr><td style="text-align:left">a[i] = b</td><td style="text-align:left">a.set(i, b)</td></tr><tr><td style="text-align:left">a[i, j] = b</td><td style="text-align:left">a.set(i, j, b)</td></tr><tr><td style="text-align:left">a[i_1, …, i_n] = b</td><td style="text-align:left">a.set(i_1, …, i_n, b)</td></tr><tr><td style="text-align:left">a == b</td><td style="text-align:left">a?.equals(b) ?: (b === null)</td></tr><tr><td style="text-align:left">a != b</td><td style="text-align:left">!(a?.equals(b) ?: (b === null))</td></tr><tr><td style="text-align:left">a()</td><td style="text-align:left">a.invoke()</td></tr><tr><td style="text-align:left">a(i)</td><td style="text-align:left">a.invoke(i)</td></tr><tr><td style="text-align:left">a(i, j)</td><td style="text-align:left">a.invoke(i, j)</td></tr><tr><td style="text-align:left">a(i_1, …, i_n)</td><td style="text-align:left">a.invoke(i_1, …, i_n)</td></tr><tr><td style="text-align:left">a &gt; b</td><td style="text-align:left">a.compareTo(b) &gt; 0</td></tr><tr><td style="text-align:left">a &lt; b</td><td style="text-align:left">a.compareTo(b) &lt; 0</td></tr><tr><td style="text-align:left">a &gt;= b</td><td style="text-align:left">a.compareTo(b) &gt;= 0</td></tr><tr><td style="text-align:left">a &lt;= b</td><td style="text-align:left">a.compareTo(b) &lt;= 0</td></tr></tbody></table><p>&#8195;&#8195;尝试在你自己的例子中使用上面的运算符，分享一下你的经历。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&#8195;&#8195;在本文中，你已经学习了如何在原始类型数据或自定义类之间使用运算符并重载相应的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;#8195;&amp;#8195;在这篇文章里，你将学习到运算符知识及它们在Kotlin中的运用。&lt;br&gt;&amp;#8195;&amp;#8195;但是在进入正题之前，我已经在之前的文章里解释了如何在Android Studio中配置Kotlin开发环境及Kotlin语言变量。如果你还有不清楚的地方，请先阅读之前的文章再来进行这篇文章知识的学习。&lt;/p&gt;
&lt;h5 id=&quot;第一章：在Android-Studio中配置Kotlin环境&quot;&gt;&lt;a href=&quot;#第一章：在Android-Studio中配置Kotlin环境&quot; class=&quot;headerlink&quot; title=&quot;第一章：在Android Studio中配置Kotlin环境&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://chuyao.github.io/2017/08/10/kotlin-android-tutorial-1/&quot;&gt;第一章：在Android Studio中配置Kotlin环境&lt;/a&gt;&lt;/h5&gt;&lt;h5 id=&quot;第二章：Kotlin变量-Android&quot;&gt;&lt;a href=&quot;#第二章：Kotlin变量-Android&quot; class=&quot;headerlink&quot; title=&quot;第二章：Kotlin变量 (Android)&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://chuyao.github.io/2017/08/13/kotlin-android-tutorial-2/&quot;&gt;第二章：Kotlin变量 (Android)&lt;/a&gt;&lt;/h5&gt;&lt;h4 id=&quot;二进制运算符&quot;&gt;&lt;a href=&quot;#二进制运算符&quot; class=&quot;headerlink&quot; title=&quot;二进制运算符&quot;&gt;&lt;/a&gt;二进制运算符&lt;/h4&gt;&lt;p&gt;&amp;#8195;&amp;#8195;在运算符的使用上，Kotlin是一门强大的语言。在其它计算机语言如Java中，是不允许用户在非原始类型数据间使用算术运算符的。你想对ArrayList使用“&lt;em&gt;+&lt;/em&gt;”，是不允许的。但Kotlin可以，Kotlin提供了二进制运算符相对应的可重载的方法名。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;表达式&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;方法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;a + b&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;a.plus(b)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;a - b&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;a.minus(b)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;a * b&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;a.times(b)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;a / b&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;a.div(b)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;a % b&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;a.rem(b), a.mod(b)(过时的)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;a..b&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;a.rangeTo(b)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&quot;注意&quot;&gt;&lt;a href=&quot;#注意&quot; class=&quot;headerlink&quot; title=&quot;注意&quot;&gt;&lt;/a&gt;注意&lt;/h5&gt;&lt;p&gt;&amp;#8195;&amp;#8195;如果你正在使用的Kotlin是1.1版本，请使用&lt;em&gt;rem()&lt;/em&gt;方法，&lt;em&gt;mod()&lt;/em&gt;方法从1.1版本开始已经过时了。&lt;br&gt;&amp;#8195;&amp;#8195;如你所见，每一个二进制运算符都有一个方法让它更易读。当你想对自定义的类使用运算方法时，你会感觉很容易使用以及重载。&lt;br&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test&lt;/span&gt;&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; count: &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;plus&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(increment: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;: Test &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Test(count + increment)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(multiply: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;: Test &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Test(count + multiply)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; test = Test(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;println(test + &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)  &lt;span class=&quot;comment&quot;&gt;//输出 -&amp;gt; Test(count=20)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;println(test * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)   &lt;span class=&quot;comment&quot;&gt;//输出 -&amp;gt; Test(count=12)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://chuyao.github.io/categories/Tech/"/>
    
    
      <category term="Android" scheme="https://chuyao.github.io/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://chuyao.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin基础教程第二章：Kotlin变量 (Android)</title>
    <link href="https://chuyao.github.io/2017/08/13/kotlin-android-tutorial-2/"/>
    <id>https://chuyao.github.io/2017/08/13/kotlin-android-tutorial-2/</id>
    <published>2017-08-13T09:31:07.000Z</published>
    <updated>2021-05-26T05:06:13.946Z</updated>
    
    <content type="html"><![CDATA[<p>&#8195;&#8195;这篇文章，你将学习到Kotlin变量的相关知识。<br>&#8195;&#8195;在进入今天的主题之前，在上一篇文章，我已经解释了如何在Android Studio中配置Kotlin开发环境，如果对此你还有疑虑，在学习今天的知识前，请先阅读上一篇文章。</p><h5 id="在Android-Studio上配置Kotlin开发环境"><a href="#在Android-Studio上配置Kotlin开发环境" class="headerlink" title="在Android Studio上配置Kotlin开发环境"></a><em><a href="https://chuyao.github.io/2017/08/10/kotlin-android-tutorial-1/">在Android Studio上配置Kotlin开发环境</a></em></h5><h4 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h4><p>&#8195;&#8195;在Kotlin中，<em>一切都是对象</em></p><blockquote><p>在Kotlin中，一切都是对象。这里没有我们在Java中使用的原始数据类型。这真的是很有意思，因为对于所有的变量，我们都可以使用同样的方式来对待。–<a href="https://antonioleiva.com/about/" target="_blank" rel="noopener">安东尼奥.雷瓦</a></p></blockquote><p>&#8195;&#8195;是的，这是真的，这是Kotlin非常酷炫的地方，而原因，“安东尼奥.雷瓦”已经说过了。让我们来定义第一个变量。</p><h4 id="定义第一个变量"><a href="#定义第一个变量" class="headerlink" title="定义第一个变量"></a>定义第一个变量</h4><p>&#8195;&#8195;你可以使用<em>var</em>或<em>val</em>关键字简单的定义变量并指派给对象。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &lt;object_name&gt; : &lt;Type&gt; = &lt;Value&gt;</span><br><span class="line"><span class="keyword">val</span> &lt;object_name&gt; : &lt;Type&gt; = &lt;Value&gt;</span><br></pre></td></tr></table></figure></p><h5 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i : <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> d : <span class="built_in">Double</span> = <span class="number">1.1</span></span><br><span class="line"><span class="keyword">var</span> f : <span class="built_in">Float</span> = <span class="number">1.1F</span></span><br><span class="line"><span class="keyword">var</span> l : <span class="built_in">Long</span> = <span class="number">1L</span></span><br><span class="line"><span class="keyword">var</span> c : <span class="built_in">Char</span> = <span class="string">'c'</span></span><br><span class="line"><span class="keyword">var</span> s : String = <span class="string">"Allen"</span></span><br></pre></td></tr></table></figure><p>&#8195;&#8195;上边的例子将立即对对象进行赋值，通过例子，你可有什么发现？<a id="more"></a><br>&#8195;&#8195;没有？<br>&#8195;&#8195;分号！<br>&#8195;&#8195;你可以更简单一点，就像下边这样<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="number">1.1</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="number">1.1F</span></span><br><span class="line"><span class="keyword">var</span> l = <span class="number">1L</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="string">'c'</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"Allen"</span></span><br></pre></td></tr></table></figure></p><p>&#8195;&#8195;通过不同的赋值，变量将被创建为特殊的某一类型。很有趣，是吗！<br>&#8195;&#8195;下边表格列出的是你定义的对象类型在内存中的占用情况(比特位数)</p><p><img src="/2017/08/13/kotlin-android-tutorial-2/3.png" alt="类型位宽"><br>&#8195;&#8195;你也可以用任何一个已定义的变量并把它赋值给一个新的变量来创建一个对象。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ii = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> dd = d + <span class="number">2.0</span></span><br><span class="line"><span class="keyword">var</span> ff = f + <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> ll = l + <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> ss = s + <span class="string">" Shi"</span></span><br><span class="line"></span><br><span class="line">println(<span class="string">"ii : <span class="variable">$ii</span>, dd : <span class="variable">$dd</span>, ff : <span class="variable">$ff</span>, ll : <span class="variable">$ll</span>, ss : <span class="variable">$ss</span>"</span>)</span><br></pre></td></tr></table></figure></p><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ii : <span class="number">2</span></span><br><span class="line">dd : <span class="number">3.1</span></span><br><span class="line">ff : <span class="number">2.1</span></span><br><span class="line">ll : <span class="number">2</span></span><br><span class="line">ss : Allen Shi</span><br></pre></td></tr></table></figure><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>&#8195;&#8195;在Kotlin中，<em>var</em>变量很常见，它是可变的，可以被多次赋值。而<em>val</em>则指常量，即，它只能被初始化一次。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mutable : <span class="built_in">Int</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">val</span> immutable : <span class="built_in">Int</span> = <span class="number">5</span></span><br><span class="line">mutable = <span class="number">10</span>    <span class="comment">//合法</span></span><br><span class="line">immutable = <span class="number">10</span>  <span class="comment">//非法</span></span><br></pre></td></tr></table></figure></p><p>&#8195;&#8195;在Java中，我们常不知不觉使用可变量实例，这让我们经常面对对象在多个地方修改带来的许多问题。当我们创建一个不可变对象时，它可以一直保持它原有的状态，如果我们想要改变它，则需要创建另外一个对象。<br>&#8195;&#8195;在使用Kotlin开发应用时，建议尽量多使用<em>val</em>变量。它们不受当前线程影响，因而它们是线程安全的。</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>&#8195;&#8195;这对Kotlin来说太简单了。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"Allen"</span></span><br><span class="line"><span class="keyword">var</span> ss = <span class="string">"My name is <span class="variable">$s</span>"</span>  <span class="comment">// My name is Allen</span></span><br><span class="line"><span class="keyword">var</span> c = s[<span class="number">2</span>]              <span class="comment">// c将赋值为字符'i'</span></span><br></pre></td></tr></table></figure></p><p>&#8195;&#8195;使用<em>$</em>(美元符号)，可以引用一个对象的值。你也可以把一个字符串看待成一个数组，通过给某一个数组元素赋值来改变这个对象。</p><h4 id="安全的空指针"><a href="#安全的空指针" class="headerlink" title="安全的空指针"></a>安全的空指针</h4><p>&#8195;&#8195;在以前的文章里，我说过Kotlin是空指针安全的。原因是Kotlin不允许用户将对象赋值<em>NULL</em>，除非你告诉Kotlin某个对象可能是空的才允许你那么做。你可以在类型后面加一个<em>?</em>(问号)来实现。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s : String = <span class="string">"Allen"</span></span><br><span class="line">s = <span class="literal">null</span> <span class="comment">//异常</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s : String? = <span class="string">"Allen"</span></span><br><span class="line">s = <span class="literal">null</span> <span class="comment">//正确</span></span><br></pre></td></tr></table></figure></p><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>&#8195;&#8195;和Java不同，Kotlin没有自动类型转换，你需要自己声明你需要的转换类型。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> i : <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> d : <span class="built_in">Double</span> = i              <span class="comment">//不可以</span></span><br><span class="line"><span class="keyword">val</span> d : <span class="built_in">Double</span> = i.toDouble()   <span class="comment">//可以</span></span><br></pre></td></tr></table></figure></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&#8195;&#8195;在本文中，你将学习到如何定义不同类型的变量，<em>var</em>和<em>val</em>关键字的区别，如何从一个类型变量转换到另一个类型的变量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;#8195;&amp;#8195;这篇文章，你将学习到Kotlin变量的相关知识。&lt;br&gt;&amp;#8195;&amp;#8195;在进入今天的主题之前，在上一篇文章，我已经解释了如何在Android Studio中配置Kotlin开发环境，如果对此你还有疑虑，在学习今天的知识前，请先阅读上一篇文章。&lt;/p&gt;
&lt;h5 id=&quot;在Android-Studio上配置Kotlin开发环境&quot;&gt;&lt;a href=&quot;#在Android-Studio上配置Kotlin开发环境&quot; class=&quot;headerlink&quot; title=&quot;在Android Studio上配置Kotlin开发环境&quot;&gt;&lt;/a&gt;&lt;em&gt;&lt;a href=&quot;https://chuyao.github.io/2017/08/10/kotlin-android-tutorial-1/&quot;&gt;在Android Studio上配置Kotlin开发环境&lt;/a&gt;&lt;/em&gt;&lt;/h5&gt;&lt;h4 id=&quot;变量的定义&quot;&gt;&lt;a href=&quot;#变量的定义&quot; class=&quot;headerlink&quot; title=&quot;变量的定义&quot;&gt;&lt;/a&gt;变量的定义&lt;/h4&gt;&lt;p&gt;&amp;#8195;&amp;#8195;在Kotlin中，&lt;em&gt;一切都是对象&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在Kotlin中，一切都是对象。这里没有我们在Java中使用的原始数据类型。这真的是很有意思，因为对于所有的变量，我们都可以使用同样的方式来对待。–&lt;a href=&quot;https://antonioleiva.com/about/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安东尼奥.雷瓦&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;#8195;&amp;#8195;是的，这是真的，这是Kotlin非常酷炫的地方，而原因，“安东尼奥.雷瓦”已经说过了。让我们来定义第一个变量。&lt;/p&gt;
&lt;h4 id=&quot;定义第一个变量&quot;&gt;&lt;a href=&quot;#定义第一个变量&quot; class=&quot;headerlink&quot; title=&quot;定义第一个变量&quot;&gt;&lt;/a&gt;定义第一个变量&lt;/h4&gt;&lt;p&gt;&amp;#8195;&amp;#8195;你可以使用&lt;em&gt;var&lt;/em&gt;或&lt;em&gt;val&lt;/em&gt;关键字简单的定义变量并指派给对象。&lt;br&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &amp;lt;object_name&amp;gt; : &amp;lt;Type&amp;gt; = &amp;lt;Value&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; &amp;lt;object_name&amp;gt; : &amp;lt;Type&amp;gt; = &amp;lt;Value&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h5 id=&quot;例如&quot;&gt;&lt;a href=&quot;#例如&quot; class=&quot;headerlink&quot; title=&quot;例如&quot;&gt;&lt;/a&gt;例如&lt;/h5&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i : &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; d : &lt;span class=&quot;built_in&quot;&gt;Double&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;1.1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; f : &lt;span class=&quot;built_in&quot;&gt;Float&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;1.1F&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; l : &lt;span class=&quot;built_in&quot;&gt;Long&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;1L&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; c : &lt;span class=&quot;built_in&quot;&gt;Char&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s : String = &lt;span class=&quot;string&quot;&gt;&quot;Allen&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&amp;#8195;&amp;#8195;上边的例子将立即对对象进行赋值，通过例子，你可有什么发现？&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://chuyao.github.io/categories/Tech/"/>
    
    
      <category term="Android" scheme="https://chuyao.github.io/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://chuyao.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin基础教程第一章：在Android Studio中配置Kotlin环境</title>
    <link href="https://chuyao.github.io/2017/08/10/kotlin-android-tutorial-1/"/>
    <id>https://chuyao.github.io/2017/08/10/kotlin-android-tutorial-1/</id>
    <published>2017-08-10T07:36:15.000Z</published>
    <updated>2021-05-26T05:06:13.939Z</updated>
    
    <content type="html"><![CDATA[<p>&#8195;&#8195;如果你之前了解过Kotlin，认为它是一门很强大的语言，那么你应该尝试去学习和使用它，这就是你来到这里的原因。这篇文章，我们将学习如何配置Android Studio下的Kotlin开发环境。<br>&#8195;&#8195;启动Android Studio，新建一个项目工程，如下图如示<br><img src="/2017/08/10/kotlin-android-tutorial-1/1.png" alt="新工程 + Kotlin支持(需要手动勾选)"><br>&#8195;&#8195;按照下一步提示创建工程并等待创建过程完成。</p><p>&#8195;&#8195;<em>对于Android Studio 2.x版本，你需要预先安装Kotlin插件，安装步骤为“File -&gt; Settings -&gt; Plugin”，在弹出的对话框搜索栏内搜索“Kotlin”，安装并重启你的Android Studio。</em><br><img src="/2017/08/10/kotlin-android-tutorial-1/1_1.png" alt="2.x版本kotlin插件安装"></p><p>&#8195;&#8195;先让我们看一下新建工程的<em>gradle</em>文件。<br><img src="/2017/08/10/kotlin-android-tutorial-1/2.png" alt="工程根目录build.gradle"></p><ol><li>Kotlin依赖版本声明；(这篇文章编写时，版本号为1.1.4)<a id="more"></a></li><li>Kotlin依赖插件声明。</li></ol><p><em>阿里云maven镜像声明</em><br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maven&#123; url <span class="string">'http://maven.aliyun.com/nexus/content/groups/public/'</span>&#125;  <span class="comment">//使用阿里云镜像，可以加快gradle或kolin插件的更新速度</span></span><br></pre></td></tr></table></figure></p><p>&#8195;&#8195;接着来看主模块的<em>gradle</em>文件。<br><img src="/2017/08/10/kotlin-android-tutorial-1/3.png" alt="主模块目录build.gradle"></p><ol><li>插件应用于该模块；</li><li>Kotlin标准库。你可以从<a href="https://kotlinlang.org/api/latest/jvm/stdlib/" target="_blank" rel="noopener">Kotlin官网</a>获取更多相关信息。</li></ol><p>&#8195;&#8195;你应该已经注意到，当Kotlin类创建时，类文件的后缀名默认已经变成“.kt”。<br><img src="/2017/08/10/kotlin-android-tutorial-1/4.png" alt="MainActivity.kt"></p><ol><li>所有的实例对象以冒号“:”和类的默认构造器形式展现。</li><li>所有的重写方法以<em>override</em>关键字开头。</li><li>你需要在实例对象后面加一个问号“<em>?</em>”来声明它是一个对象。</li></ol><p>&#8195;&#8195;现在，像以往一样运行你的应用。<br><img src="/2017/08/10/kotlin-android-tutorial-1/5.png" alt="输出HelloKotlin"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;#8195;&amp;#8195;如果你之前了解过Kotlin，认为它是一门很强大的语言，那么你应该尝试去学习和使用它，这就是你来到这里的原因。这篇文章，我们将学习如何配置Android Studio下的Kotlin开发环境。&lt;br&gt;&amp;#8195;&amp;#8195;启动Android Studio，新建一个项目工程，如下图如示&lt;br&gt;&lt;img src=&quot;/2017/08/10/kotlin-android-tutorial-1/1.png&quot; alt=&quot;新工程 + Kotlin支持(需要手动勾选)&quot;&gt;&lt;br&gt;&amp;#8195;&amp;#8195;按照下一步提示创建工程并等待创建过程完成。&lt;/p&gt;
&lt;p&gt;&amp;#8195;&amp;#8195;&lt;em&gt;对于Android Studio 2.x版本，你需要预先安装Kotlin插件，安装步骤为“File -&amp;gt; Settings -&amp;gt; Plugin”，在弹出的对话框搜索栏内搜索“Kotlin”，安装并重启你的Android Studio。&lt;/em&gt;&lt;br&gt;&lt;img src=&quot;/2017/08/10/kotlin-android-tutorial-1/1_1.png&quot; alt=&quot;2.x版本kotlin插件安装&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;#8195;&amp;#8195;先让我们看一下新建工程的&lt;em&gt;gradle&lt;/em&gt;文件。&lt;br&gt;&lt;img src=&quot;/2017/08/10/kotlin-android-tutorial-1/2.png&quot; alt=&quot;工程根目录build.gradle&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Kotlin依赖版本声明；(这篇文章编写时，版本号为1.1.4)&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://chuyao.github.io/categories/Tech/"/>
    
    
      <category term="Android" scheme="https://chuyao.github.io/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://chuyao.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>(译) 解决Nexus5X手机死循环启动问题，帮助你最终启动手机</title>
    <link href="https://chuyao.github.io/2017/07/31/nexus5x-bootloop-fix/"/>
    <id>https://chuyao.github.io/2017/07/31/nexus5x-bootloop-fix/</id>
    <published>2017-07-31T06:22:18.000Z</published>
    <updated>2021-05-26T05:06:13.956Z</updated>
    
    <content type="html"><![CDATA[<h5 id="原文《Nexus-5X-Bootloop-Fix-Helps-you-to-Finally-Boot-the-Phone》，原文作者：Doug-Lynch，源自-xda-developers-com网站"><a href="#原文《Nexus-5X-Bootloop-Fix-Helps-you-to-Finally-Boot-the-Phone》，原文作者：Doug-Lynch，源自-xda-developers-com网站" class="headerlink" title="原文《Nexus 5X Bootloop Fix Helps you to Finally Boot the Phone》，原文作者：Doug Lynch，源自 xda-developers.com网站"></a><center><em>原文<a href="https://www.xda-developers.com/nexus-5x-bootloop-fix-boot-phone/" target="_blank" rel="noopener">《Nexus 5X Bootloop Fix Helps you to Finally Boot the Phone》</a>，原文作者：<a href="https://www.xda-developers.com/author/doug-lynch/" target="_blank" rel="noopener">Doug Lynch</a>，源自 <a href="https://www.xda-developers.com/" target="_blank" rel="noopener">xda-developers.com</a>网站</em></center></h5><p>&#8195;&#8195;你的LG/Google <a href="https://forum.xda-developers.com/nexus-5x" target="_blank" rel="noopener">Nexus 5X</a>手机停止启动了吗？或者是陷入到了无休止的启动循环里了？<br>&#8195;&#8195;这种现象我们常称之为“循环启动”，起因则有很多种。大多数时候，可以通过刷入原厂固件或者恢复出厂设置来解决循环启动问题，但当遇到硬件循环启动时，通常我们并不能采取什么有效的办法，除了退货。如果你的Google Nexus 5X手机无法启动，而你尝试修复但并没有什么卵用，那么你要相信，你不是唯一一个碰到这种情况的人。Nexus 5X循环启动问题在社区里正不断被诟病，但鲜有新的解决方案。</p><h3 id="Nexus-5X循环启动解决-背景"><a href="#Nexus-5X循环启动解决-背景" class="headerlink" title="Nexus 5X循环启动解决 - 背景"></a>Nexus 5X循环启动解决 - 背景</h3><p>&#8195;&#8195;过去几年里，LG旗下的智能手机在循环启动问题上有点名声。其中一个问题，起初只在<a href="https://forum.xda-developers.com/g4" target="_blank" rel="noopener">LG G4</a>手机上发现的问题正越来越多的出现在它发布的每一款新设备上。社区里最近在讨论<em><a href="https://www.xda-developers.com/nexus-6p-bootloop-fix/" target="_blank" rel="noopener">解决Nexus 6P循环启动问题</a></em>，这个设备由华为出品，而现在，一个在<a href="https://forum.xda-developers.com/nexus-5x" target="_blank" rel="noopener">Nexus 5X</a>上可行的办法出现了，这个办法派生自我们之前写的一些引导方案。<br>&#8195;&#8195;这些解决方案有一个共同点，正表明由高通仓促发布的骁龙808/810芯片，随着使用时间的推移，正在达到退化并损坏的时候了。<em><a href="https://www.xda-developers.com/opinion-the-810-held-back-a-generation-with-deliberate-apologism-damage-control/" target="_blank" rel="noopener">骁龙810发热问题</a></em>都已经老生常谈了，但是，似乎808芯片也存在相同的问题，将导致设备循环启动。LG起初承认了<em><a href="https://www.xda-developers.com/xda-external-link/lg-admits-g4-bootloop-problem-is-a-hardware-fault-will-repair-affected-devices/" target="_blank" rel="noopener">LG G4循环启动问题确实和硬件有关</a></em>，但从未提供更多深入的信息。<br>&#8195;&#8195;一些质疑认为是焊锡的问题，在设备的使用过程中，在经历多次的加热和冷却后，焊锡会破裂。不管是否是真因，我们还是不知道问题的背后是什么，但是这个办法看起来会对Nexus 5X循环启动的问题起效。今天我们带来一个引导，真正的帮助你解决Nexus 5X循环启动问题。这则帖子末尾的讨论链接表明这个办法是未经测试的，社区里的许多用户已经报告了用这个办法可以成功。<br>&#8195;&#8195;一如既往，你可以使这个方法多样化。</p><h3 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h3><h6 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h6><ul><li><em>设备在循环启动问题发生前，bootloader要处于”可解锁”状态。在这之前，如果你能启动设备，去到开发者选项里，点击“允许OEM解锁”，就能达到bootloader解锁的状态。</em></li></ul><ol><li>下载最新的<a href="https://www.xda-developers.com/google-releases-separate-adb-and-fastboot-binary-downloads/" target="_blank" rel="noopener">ADB和Fastboot</a>，将它们解压到电脑上容易访问到的位置。<a id="more"></a></li><li>下载安装<a href="https://developer.android.com/studio/run/win-usb.html" target="_blank" rel="noopener">谷歌USB驱动</a> (针对windows平台)</li><li>下载<a href="https://www.dropbox.com/s/tm7qt98r6d7q2a6/N2G47Z_4Cores.img?dl=0" target="_blank" rel="noopener">N2G47Z_4Cores.img</a>文件，并保存到与ADB&amp;Fastboot相同的目录下。<ul><li>可选项1：如果想要在Nexus 5X上使用TWRP recovery，则需要一个TWRP的修改版本。下载<a href="https://www.dropbox.com/s/levla3p5npe24pw/TWRP3_1_1_5X.img?dl=0" target="_blank" rel="noopener">TWRP3_1_1_5X.img</a>，并保存到与ADB&amp;Fastboot相同的目录下。</li><li>可选项2：如果想要加快Nexus 5X的运行速度，则可以刷入一个经过XDA认证的<a href="https://forum.xda-developers.com/member.php?u=4684315" target="_blank" rel="noopener">flar2</a>的修改版本基带内核。下载<a href="https://www.dropbox.com/s/172ey8346e5du6l/EX4_10_5X.zip?dl=0" target="_blank" rel="noopener">EX4_10_5X.zip</a>文件到Nexus 5X上默认的下载目录。</li></ul></li><li>将Nexus 5X通过USB线与电脑连接。</li><li>启动电脑命令行工具并定位到之前保存ADB&amp;Fastboot的目录下，对于Windows用户，只需要资源管理器进入到这个目录下，点击鼠标右键，选择”open commad promote here”，即，“在这里打开命令行”即可，Windows10用户可以选择PowerShell替代。<br><img src="/2017/07/31/nexus5x-bootloop-fix/1.png" alt></li><li>启动Nexus 5X并进入到Fastboot模式(同时按住电源键及音量下键)。</li><li>在命令行执行命令: <em>fastboot devices</em><br><img src="/2017/07/31/nexus5x-bootloop-fix/2.png" alt></li><li>如果能看到显示的设备序列号，则可以继续，如果没有，则可能是因为某些原因，USB驱动没有安装好，需要检查。</li><li>如果bootloader未解锁而之前已经在手机开发者选项里进行了OEM解锁，则现在可以解锁bootloader了，命令行输入: <em>fastboot flashing unlock</em> 然后，跟着命令行提示进行bootloader解锁，需要注意的是，这个操作会清除手机上的所有数据。</li><li>接着进行替换boot镜像，输入命令: <em>fastboot flash boot N2G47Z_4Cores.img</em><br><img src="/2017/07/31/nexus5x-bootloop-fix/3.png" alt><ul><li>如果想要刷入TWRP，使用命令: <em>fastboot flash recovery TWRP3_1_1_5X.img</em><br><img src="/2017/07/31/nexus5x-bootloop-fix/4.png" alt></li></ul></li><li>输入命令: <em>fastboot reboot</em>来重启手机<br><img src="/2017/07/31/nexus5x-bootloop-fix/5.png" alt></li><li>几分钟后(可能更长)，应该可以看到开机动画在屏幕上闪动，那么恭喜你，你拯救了你的爱机！</li><li>可选项: 如果想要改进手机的表现力，可以遵照以下步骤来安装TWRP，拷贝之前下载的基带内核文件到手机内置存储器上，启动手机并进入到TWRP，并刷入内核。这时你甚至可以选择通过超频来加快手机的运行速度。</li></ol><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>&#8195;&#8195;就像我们之前呈现的解决Nexus 6P循环启动问题解决指引一样，在现在SOC的大集群CPU时代，有许多原因会造成这些问题。XDA会员<a href="https://forum.xda-developers.com/member.php?u=5288606" target="_blank" rel="noopener">XCnathan32</a>在测试时发现，这个问题是由于VLL在A57内核里无法获取进程锁造成的。目前，我们也未100%肯定是这个原因引起这个问题，但是，我们的解决办法都是在不让A57内核损坏的情况下达成，成功解决了问题。<br>&#8195;&#8195;更好的解决办法未来会出现，但现在，我们很感激有开发者社区里出现了解决方案，让人们的手机获得重生。那些解决了这些问题的人，他们至少都有相关的设备，例如音乐播放器等，在他们第一次面对循环启动的问题时，他们至少有了一个可行的解决办法。<br>&#8195;&#8195;就像前面所说的，我们看到了社区里有人反应这个方法(XDA官方方法)确实可行。然而，我们也确实看到不止一个用户反馈这对于他们没有效果。引起Nexus 5X循环启动的原因有很多，所以我们的指引可能并不适用于所有人。如果你的Nexus 5X正在经历循环启动的遭遇，而你想重置所有这些修改过的文件，也将不会对你以后想刷入谷歌提供的固件镜像有什么影响。</p><h4 id="这里可以查看我们之前关于Nexus-5X的帖子"><a href="#这里可以查看我们之前关于Nexus-5X的帖子" class="headerlink" title="这里可以查看我们之前关于Nexus 5X的帖子"></a><em><a href="https://forum.xda-developers.com/nexus-5x/general/untested-nexus-5x-bootloop-death-fix-t3641199" target="_blank" rel="noopener">这里可以查看我们之前关于Nexus 5X的帖子</a></em></h4>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;原文《Nexus-5X-Bootloop-Fix-Helps-you-to-Finally-Boot-the-Phone》，原文作者：Doug-Lynch，源自-xda-developers-com网站&quot;&gt;&lt;a href=&quot;#原文《Nexus-5X-Bootloop-Fix-Helps-you-to-Finally-Boot-the-Phone》，原文作者：Doug-Lynch，源自-xda-developers-com网站&quot; class=&quot;headerlink&quot; title=&quot;原文《Nexus 5X Bootloop Fix Helps you to Finally Boot the Phone》，原文作者：Doug Lynch，源自 xda-developers.com网站&quot;&gt;&lt;/a&gt;&lt;center&gt;&lt;em&gt;原文&lt;a href=&quot;https://www.xda-developers.com/nexus-5x-bootloop-fix-boot-phone/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Nexus 5X Bootloop Fix Helps you to Finally Boot the Phone》&lt;/a&gt;，原文作者：&lt;a href=&quot;https://www.xda-developers.com/author/doug-lynch/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Doug Lynch&lt;/a&gt;，源自 &lt;a href=&quot;https://www.xda-developers.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;xda-developers.com&lt;/a&gt;网站&lt;/em&gt;&lt;/center&gt;&lt;/h5&gt;&lt;p&gt;&amp;#8195;&amp;#8195;你的LG/Google &lt;a href=&quot;https://forum.xda-developers.com/nexus-5x&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nexus 5X&lt;/a&gt;手机停止启动了吗？或者是陷入到了无休止的启动循环里了？&lt;br&gt;&amp;#8195;&amp;#8195;这种现象我们常称之为“循环启动”，起因则有很多种。大多数时候，可以通过刷入原厂固件或者恢复出厂设置来解决循环启动问题，但当遇到硬件循环启动时，通常我们并不能采取什么有效的办法，除了退货。如果你的Google Nexus 5X手机无法启动，而你尝试修复但并没有什么卵用，那么你要相信，你不是唯一一个碰到这种情况的人。Nexus 5X循环启动问题在社区里正不断被诟病，但鲜有新的解决方案。&lt;/p&gt;
&lt;h3 id=&quot;Nexus-5X循环启动解决-背景&quot;&gt;&lt;a href=&quot;#Nexus-5X循环启动解决-背景&quot; class=&quot;headerlink&quot; title=&quot;Nexus 5X循环启动解决 - 背景&quot;&gt;&lt;/a&gt;Nexus 5X循环启动解决 - 背景&lt;/h3&gt;&lt;p&gt;&amp;#8195;&amp;#8195;过去几年里，LG旗下的智能手机在循环启动问题上有点名声。其中一个问题，起初只在&lt;a href=&quot;https://forum.xda-developers.com/g4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LG G4&lt;/a&gt;手机上发现的问题正越来越多的出现在它发布的每一款新设备上。社区里最近在讨论&lt;em&gt;&lt;a href=&quot;https://www.xda-developers.com/nexus-6p-bootloop-fix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;解决Nexus 6P循环启动问题&lt;/a&gt;&lt;/em&gt;，这个设备由华为出品，而现在，一个在&lt;a href=&quot;https://forum.xda-developers.com/nexus-5x&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nexus 5X&lt;/a&gt;上可行的办法出现了，这个办法派生自我们之前写的一些引导方案。&lt;br&gt;&amp;#8195;&amp;#8195;这些解决方案有一个共同点，正表明由高通仓促发布的骁龙808/810芯片，随着使用时间的推移，正在达到退化并损坏的时候了。&lt;em&gt;&lt;a href=&quot;https://www.xda-developers.com/opinion-the-810-held-back-a-generation-with-deliberate-apologism-damage-control/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;骁龙810发热问题&lt;/a&gt;&lt;/em&gt;都已经老生常谈了，但是，似乎808芯片也存在相同的问题，将导致设备循环启动。LG起初承认了&lt;em&gt;&lt;a href=&quot;https://www.xda-developers.com/xda-external-link/lg-admits-g4-bootloop-problem-is-a-hardware-fault-will-repair-affected-devices/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LG G4循环启动问题确实和硬件有关&lt;/a&gt;&lt;/em&gt;，但从未提供更多深入的信息。&lt;br&gt;&amp;#8195;&amp;#8195;一些质疑认为是焊锡的问题，在设备的使用过程中，在经历多次的加热和冷却后，焊锡会破裂。不管是否是真因，我们还是不知道问题的背后是什么，但是这个办法看起来会对Nexus 5X循环启动的问题起效。今天我们带来一个引导，真正的帮助你解决Nexus 5X循环启动问题。这则帖子末尾的讨论链接表明这个办法是未经测试的，社区里的许多用户已经报告了用这个办法可以成功。&lt;br&gt;&amp;#8195;&amp;#8195;一如既往，你可以使这个方法多样化。&lt;/p&gt;
&lt;h3 id=&quot;教程&quot;&gt;&lt;a href=&quot;#教程&quot; class=&quot;headerlink&quot; title=&quot;教程&quot;&gt;&lt;/a&gt;教程&lt;/h3&gt;&lt;h6 id=&quot;要求&quot;&gt;&lt;a href=&quot;#要求&quot; class=&quot;headerlink&quot; title=&quot;要求&quot;&gt;&lt;/a&gt;要求&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;&lt;em&gt;设备在循环启动问题发生前，bootloader要处于”可解锁”状态。在这之前，如果你能启动设备，去到开发者选项里，点击“允许OEM解锁”，就能达到bootloader解锁的状态。&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;下载最新的&lt;a href=&quot;https://www.xda-developers.com/google-releases-separate-adb-and-fastboot-binary-downloads/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ADB和Fastboot&lt;/a&gt;，将它们解压到电脑上容易访问到的位置。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://chuyao.github.io/categories/Tech/"/>
    
    
      <category term="Android" scheme="https://chuyao.github.io/tags/Android/"/>
    
      <category term="Translation" scheme="https://chuyao.github.io/tags/Translation/"/>
    
      <category term="Nexus 5X" scheme="https://chuyao.github.io/tags/Nexus-5X/"/>
    
  </entry>
  
  <entry>
    <title>一个简单的Node.js接口服务器</title>
    <link href="https://chuyao.github.io/2017/07/11/simple-api-server-with-nodejs/"/>
    <id>https://chuyao.github.io/2017/07/11/simple-api-server-with-nodejs/</id>
    <published>2017-07-11T06:02:57.000Z</published>
    <updated>2021-05-26T05:06:13.966Z</updated>
    
    <content type="html"><![CDATA[<p>先来看个<a href="https://nodejs.org/en/about/" target="_blank" rel="noopener">官方Hello World</a>，几行代码即可搭建一个服务器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hostname = <span class="string">'127.0.0.1'</span>;</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.statusCode = <span class="number">200</span>;</span><br><span class="line">  res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>);</span><br><span class="line">  res.end(<span class="string">'Hello World\n'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(port, hostname, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server running at http://<span class="subst">$&#123;hostname&#125;</span>:<span class="subst">$&#123;port&#125;</span>/`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>十分简洁，只要有点javascript语法知识，就能看懂。</p><p>当然，并不是所看到的那么简单，要让这几行代码“简单”起来，需要依赖于一个安装好的Node环境，关于Node环境安装，不想赘述太多，网上的教程一大堆，这里简单总结一下：</p><ol><li>Windows系统环境<br>下载<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官方安装源</a>安装即可；</li><li>Linux系统环境<br>推荐使用<a href="https://github.com/creationix/nvm/blob/master/README.md#install-script" target="_blank" rel="noopener">nvm</a>安装及管理node版本，当然，也可以访问上面提到的官方安装源，下载安装。</li></ol><p>请尽量安装使用LTS版本，经过上边的步骤，就可以如开头所说的，快速搭建一个简单服务器了。</p><p>下边进入正题，先说一个场景，一个客户端开发人员，需要对接口进行测试，需要接口假数据，真的会有一些开发人员说：“没有数据我开发不了！”，而碰巧后端同事又还没空开发接口、做假数据，怎么办？求人不如求己！具体到开发案例场景，客户端开发需要一个升级检查功能(一般包含两部分，版本检查，高版本文件下载)，针对这个场景，今天用node.js来实现解决方案。</p><p>为了最大程度的简单，这次使用<a href="http://expressjs.com/" target="_blank" rel="noopener">Express</a>，一个目前非常流行的基于Node.js的Web应用开发框架来实现，帮助我们处理http请求及请求路由的简单实现。<a id="more"></a></p><p>系统命令行状态下，建立程序目标文件夹<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir myserver</span><br><span class="line">$ <span class="built_in">cd</span> myserver</span><br></pre></td></tr></table></figure></p><p>初始化程序包<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm init</span><br></pre></td></tr></table></figure></p><p>出现的选项提示可以都使用默认选项(即一路enter到底)</p><p>安装Express<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install express --save</span><br></pre></td></tr></table></figure></p><p>新建一个文件index.js，用记事本或其它文本编辑器打开，开始写我们的程序<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>); <span class="comment">//引入express模块</span></span><br><span class="line"><span class="keyword">var</span> app = express();  <span class="comment">//express对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> verStr = &#123;<span class="attr">versionName</span> : <span class="string">'2.0.0'</span>, <span class="attr">versionCode</span> : <span class="number">200</span>&#125;;  <span class="comment">//版本检查返回的数据，假数据，自行修改</span></span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/checkUpdate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123; <span class="comment">//版本检查接口</span></span><br><span class="line">  res.send(<span class="built_in">JSON</span>.stringify(verStr));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/download'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;  <span class="comment">//新版本文件下载接口</span></span><br><span class="line">  res.download(<span class="string">'./new-release.apk'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//服务端口监听</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server now listening at port 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>保存，并把需要测试升级的apk文件(文件名称对应为new-release.apk)放到和index.js同级目录下，最后一步，执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node index.js</span><br></pre></td></tr></table></figure></p><p>即可大功告成了。</p><p>检验一下我们的成果，在本机浏览器访问<br><code>http://localhost:3000/checkUpdate</code><br><code>http://localhost:3000/download</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先来看个&lt;a href=&quot;https://nodejs.org/en/about/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方Hello World&lt;/a&gt;，几行代码即可搭建一个服务器。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; http = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;http&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; hostname = &lt;span class=&quot;string&quot;&gt;&#39;127.0.0.1&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; port = &lt;span class=&quot;number&quot;&gt;3000&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; server = http.createServer(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;req, res&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  res.statusCode = &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  res.setHeader(&lt;span class=&quot;string&quot;&gt;&#39;Content-Type&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;text/plain&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  res.end(&lt;span class=&quot;string&quot;&gt;&#39;Hello World\n&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;server.listen(port, hostname, () =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;`Server running at http://&lt;span class=&quot;subst&quot;&gt;$&amp;#123;hostname&amp;#125;&lt;/span&gt;:&lt;span class=&quot;subst&quot;&gt;$&amp;#123;port&amp;#125;&lt;/span&gt;/`&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;十分简洁，只要有点javascript语法知识，就能看懂。&lt;/p&gt;
&lt;p&gt;当然，并不是所看到的那么简单，要让这几行代码“简单”起来，需要依赖于一个安装好的Node环境，关于Node环境安装，不想赘述太多，网上的教程一大堆，这里简单总结一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Windows系统环境&lt;br&gt;下载&lt;a href=&quot;https://nodejs.org/en/download/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方安装源&lt;/a&gt;安装即可；&lt;/li&gt;
&lt;li&gt;Linux系统环境&lt;br&gt;推荐使用&lt;a href=&quot;https://github.com/creationix/nvm/blob/master/README.md#install-script&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;nvm&lt;/a&gt;安装及管理node版本，当然，也可以访问上面提到的官方安装源，下载安装。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;请尽量安装使用LTS版本，经过上边的步骤，就可以如开头所说的，快速搭建一个简单服务器了。&lt;/p&gt;
&lt;p&gt;下边进入正题，先说一个场景，一个客户端开发人员，需要对接口进行测试，需要接口假数据，真的会有一些开发人员说：“没有数据我开发不了！”，而碰巧后端同事又还没空开发接口、做假数据，怎么办？求人不如求己！具体到开发案例场景，客户端开发需要一个升级检查功能(一般包含两部分，版本检查，高版本文件下载)，针对这个场景，今天用node.js来实现解决方案。&lt;/p&gt;
&lt;p&gt;为了最大程度的简单，这次使用&lt;a href=&quot;http://expressjs.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Express&lt;/a&gt;，一个目前非常流行的基于Node.js的Web应用开发框架来实现，帮助我们处理http请求及请求路由的简单实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://chuyao.github.io/categories/Tech/"/>
    
    
      <category term="Node.js" scheme="https://chuyao.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>消失的传统</title>
    <link href="https://chuyao.github.io/2017/07/06/the-disappearing-of-tradition/"/>
    <id>https://chuyao.github.io/2017/07/06/the-disappearing-of-tradition/</id>
    <published>2017-07-06T08:01:01.000Z</published>
    <updated>2021-05-26T05:06:13.967Z</updated>
    
    <content type="html"><![CDATA[<p>&#8195;&#8195;3月30日，农历三月三，对壮族人来说，一个传统的节日，叔公“选择”在这天离世。作为孙辈的我在惊闻噩耗第一时间往家里赶，希望能赶上为叔公送行，无奈路途遥远，路上耽误的一天时间造就了一生的遗憾。4月1日快中午到家时，看到父亲，哥哥都在自家里，我知道我回来晚了（叔公已在我到家前三个小时出殡了），下午和父亲回叔公家帮忙处理丧事善后的事情，见到了婶婆，婶婆有些憔悴但仪态平静，见到我时惊了一下，可能是没想到我能回来吧，没等我先开口便叫了我：“二，你也回来啦！”，我迎上去抓住婶婆的手：“婶婆，我回来晚了！”，婶婆拍一下我的手背：“回来了就好！”<br>&#8195;&#8195;叔公晚年失明，近些年只能待在家里，很少出门，去年中秋节是我最后一次见到叔公，那时感觉叔公精神状态还不错，听说我回来看望他，他挺高兴的，叔公说听到声音还能认出是我。虽然看不见，但叔公在家里活动时拒绝家人的搀扶指引，自己扶着墙壁前进，凭着记忆尽可能自理，仿佛他在这个世界里，并没有和失明前有什么区别。然而，那次也是近些年我和叔公为数不多的见面机会之一，这些年在外求学、工作、生活，在老家待的时间很少，每次回家也近乎匆忙，没有好好探望家里的老人们，那次见到叔公就让我感叹岁月的无情，心中也充满了愧疚。<br>&#8195;&#8195;叔公在我的印象里，极其严肃，似乎从不开玩笑；“脾气暴躁”，经常批评自己家人、家族里的人，提醒大家不要忘了家族的规矩、传统，不对的地方总是不留情面的，对家族里的小孩也是一脸严肃，下河玩水摸鱼、上山钻洞摸鸟，让叔公碰到了总要呵斥我们贪玩，其实都是在担心我们的安全；叔公几乎是是家族里威望最高的人，他利用这份威望，和家族里的其它长者一起，维系起大家族几十号人口的关系，丧事喜事号召大家一起出工出力，清明节号召一起祭拜祖上，调解各小家中的家庭矛盾。小时候，很喜欢跟着大人们去叔公参加“家族会议”，听叔公在“家族会议”上给大家“训话”，更多的，是想听那一辈老人们的故事，每次都觉得津津有味。<a id="more"></a><br>&#8195;&#8195;叔公有着村里几乎最灵巧的双手，结鱼网的手艺是一绝，经常有人上门求叔公织鱼网，叔公会制作精良的钓鱼杆，用竹篾编织精致的鱼篓、虾斗，靠着这些“精良的装备”，叔公在村里的小河里予取予求，家里鱼虾不断，在我小时候那信息闭塞、交通不便、生活物资匮乏的小山村里，叔公像是“贵族”一般，受人景仰。叔公有着无比坚韧的毅力，家里磨玉米磨豆腐的石磨是他从山里撬回的几百斤的石头，手工凿成，一台石磨一凿就是好几年才完工。叔公还多才多艺，会制作二胡，三把精美的二胡，几乎是叔公最珍贵的遗物，会制作性能优异的木陀螺，小时候做梦都想能得到一个叔公亲手制作的木陀螺，因为，那几乎意味着可以在和村里小伙伴们的斗螺活动中立于不败之地，赢得小伙伴们的羡慕的目光，那是一份最纯真的荣耀，然而直到叔公离去，我也没有得到一个属于我的木陀螺，因为叔公不想让我们贪玩，产出的木陀螺产量很低，随着我成长时间的推移，木陀螺之于我，摆脱了现实的意义，只活在了我的记忆里。<br>&#8195;&#8195;叔公做的那些事情，是真正的创造，利用简单的自然资源，为自己，为家人，最大限度的丰富生活物资，用勤劳的双手，让生活依赖但不局限于那贫瘠的一亩三分地，供养着一大家族的儿孙，他用一生坚守着小山村，“与世隔绝”。<br>&#8195;&#8195;是的，这就是我的叔公，我的家族里之于我，其实有好几位叔公，这里只提到一位，因为，我这一辈，他是最后一位叔公。<br>&#8195;&#8195;4月2日，按风俗惯例，叔公家要回请帮工们吃饭，我在后厨给父亲打下手，这些年伴随着家族里老人们的渐渐离去，我也习惯了和父亲搭档后厨的场景。最后一桌，是属于家里人，这一天的桌上，父亲当着众人的面，训起了话，主要是讲给我这一辈的兄弟姐妹们听，说我们应该更团结一点，有事大家要聚在一块，商量合作，要记住家族里的规矩，要传承家族的传统，不要让外人看笑话。的确，那天的回请宴，做的有欠缺的地方，比如食材准备有些不足，家里人没有都准时到场，到场的也没有都在尽力合作帮忙，我知道，父亲不是在说我，但也是在说我，在说家族里我这一辈的人，我是在帮忙，但都是在父亲的指引下按部就班，要是让我独立面对这些事情，我想，我还没有做好准备。那天的父亲，和叔公像极了。<br>&#8195;&#8195;叔公的离去，代表着一个时代的结束，叔公带走了很多东西，他的手艺没留下来，因为河里的鱼虾已经没那么多了，就算想吃鱼虾，第一选择也已经不是下河捕捞了；不需要再费力推磨才能吃到豆腐了；没人听二胡，更没有人想要去做一把二胡了；新生代小孩们再也不玩木陀螺了；人们无法再容忍一生只待在小山村，靠着一亩三分地过活的日子……还有更多的，无法用言语表达的东西，都在跟着叔公消逝，那些“繁缛”的风俗习惯，如婚丧，如祭祀等等，日益简化，甚至遗忘，这些，就是传统，日渐消失的传统。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;#8195;&amp;#8195;3月30日，农历三月三，对壮族人来说，一个传统的节日，叔公“选择”在这天离世。作为孙辈的我在惊闻噩耗第一时间往家里赶，希望能赶上为叔公送行，无奈路途遥远，路上耽误的一天时间造就了一生的遗憾。4月1日快中午到家时，看到父亲，哥哥都在自家里，我知道我回来晚了（叔公已在我到家前三个小时出殡了），下午和父亲回叔公家帮忙处理丧事善后的事情，见到了婶婆，婶婆有些憔悴但仪态平静，见到我时惊了一下，可能是没想到我能回来吧，没等我先开口便叫了我：“二，你也回来啦！”，我迎上去抓住婶婆的手：“婶婆，我回来晚了！”，婶婆拍一下我的手背：“回来了就好！”&lt;br&gt;&amp;#8195;&amp;#8195;叔公晚年失明，近些年只能待在家里，很少出门，去年中秋节是我最后一次见到叔公，那时感觉叔公精神状态还不错，听说我回来看望他，他挺高兴的，叔公说听到声音还能认出是我。虽然看不见，但叔公在家里活动时拒绝家人的搀扶指引，自己扶着墙壁前进，凭着记忆尽可能自理，仿佛他在这个世界里，并没有和失明前有什么区别。然而，那次也是近些年我和叔公为数不多的见面机会之一，这些年在外求学、工作、生活，在老家待的时间很少，每次回家也近乎匆忙，没有好好探望家里的老人们，那次见到叔公就让我感叹岁月的无情，心中也充满了愧疚。&lt;br&gt;&amp;#8195;&amp;#8195;叔公在我的印象里，极其严肃，似乎从不开玩笑；“脾气暴躁”，经常批评自己家人、家族里的人，提醒大家不要忘了家族的规矩、传统，不对的地方总是不留情面的，对家族里的小孩也是一脸严肃，下河玩水摸鱼、上山钻洞摸鸟，让叔公碰到了总要呵斥我们贪玩，其实都是在担心我们的安全；叔公几乎是是家族里威望最高的人，他利用这份威望，和家族里的其它长者一起，维系起大家族几十号人口的关系，丧事喜事号召大家一起出工出力，清明节号召一起祭拜祖上，调解各小家中的家庭矛盾。小时候，很喜欢跟着大人们去叔公参加“家族会议”，听叔公在“家族会议”上给大家“训话”，更多的，是想听那一辈老人们的故事，每次都觉得津津有味。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://chuyao.github.io/categories/Life/"/>
    
    
      <category term="Emotion" scheme="https://chuyao.github.io/tags/Emotion/"/>
    
  </entry>
  
  <entry>
    <title>我眼中的面试 (转)</title>
    <link href="https://chuyao.github.io/2017/06/27/interview-in-my-mind/"/>
    <id>https://chuyao.github.io/2017/06/27/interview-in-my-mind/</id>
    <published>2017-06-27T07:19:38.000Z</published>
    <updated>2021-05-26T05:06:13.938Z</updated>
    
    <content type="html"><![CDATA[<p>转载自SegmentFault <a href="https://segmentfault.com/a/1190000008682444" title="我眼中的面试" target="_blank" rel="noopener">我自己的文章</a></p><p>&#8195;&#8195;最近在给公司招Android开发人员，面向两个方向，Framework和App，近一个月的时间以来，总体特点是Framework方向近乎无人问津，而App方向则简历“泛滥”，想招个靠谱的伙伴真的不容易。最近的工作时常被频繁的面试安排打断，面试之余，想总结一下这段时间的感受。尽量从面试流程的各个环节都有一些涉及，当作回忆也好，经验也罢。当作给自己的沉淀吧。</p><h4 id="1-简历的投递"><a href="#1-简历的投递" class="headerlink" title="1. 简历的投递"></a>1. 简历的投递</h4><h6 id="Framework方向"><a href="#Framework方向" class="headerlink" title="Framework方向"></a>Framework方向</h6><p>&#8195;&#8195;基本没有“正规军”出现，这也在我的意料之中，这个方向的人材稀缺，基本都待在大厂里不出来，因为对于系统级别的定制化改造真的是“搞事情”，资源的投入是巨大的，大厂都不一定搞得好的东西，何况对于一个像我们这样的小作坊呢。因为也不是紧急的需要，所以和领导确定的方案是花多一点的时间，放长线，广撒网，另外，利用人脉关系从大厂争取捞人。</p><h6 id="App方向"><a href="#App方向" class="headerlink" title="App方向"></a>App方向</h6><p>&#8195;&#8195;不得不先提一个小插曲，根据业务的进展，先放出的是Framework方向的岗位招聘，每天收到的简历寥寥无几，领导(领导不是很懂Android)问我，Android就这点人？我笑而不语，领导你等着。App岗位一开放，每天数倍的简历压过来，领导没再说什么了，之前和我一起审简历的工作也不参与了。<br>&#8195;&#8195;两个印象，一个是现在是90后的世界了，另一个是女生们多了，这算是广大男同胞们的福音吗？</p><h4 id="2-简历的筛选"><a href="#2-简历的筛选" class="headerlink" title="2. 简历的筛选"></a>2. 简历的筛选</h4><p>&#8195;&#8195;大部分的简历还是那个老生常谈的问题，太千篇一律了，让人看了提不起兴趣的那种，顺带的水分也就不提了，各种精通～可能大家心里都有数。</p><h6 id="太“简明”的简历会被刷"><a href="#太“简明”的简历会被刷" class="headerlink" title="太“简明”的简历会被刷"></a>太“简明”的简历会被刷</h6><p>&#8195;&#8195;简明到只有各种荣誉证书各种精通，却没有具体的项目介绍，想简明可以贴个作品链接啊，那些证书、精通的我们真的不太在乎，我们只希望能多了解一些你的工作经历，当然我们真的希望你能精通。<a id="more"></a></p><h6 id="太“高明”的简历会被刷"><a href="#太“高明”的简历会被刷" class="headerlink" title="太“高明”的简历会被刷"></a>太“高明”的简历会被刷</h6><p>&#8195;&#8195;21岁5年Android开发经验，Sorry，我是遇上神童了吗？我hold不住啊！10年Android开发经验的，Sorry，我是遇上Rubin级别大神了吗？我只能膜拜，岂敢让您屈尊。</p><h6 id="太low的简历会被刷"><a href="#太low的简历会被刷" class="headerlink" title="太low的简历会被刷"></a>太low的简历会被刷</h6><p>&#8195;&#8195;简历毫无排版可言或排版混乱，让我有阅读困难的，Sorry，太出众了。不要求炫，但至少能达到平均大众水准吧，找个模板也行啊，都是出来找工作的，这几乎就是第一印象，你怎么就忍心让自己输在起跑线上？</p><h4 id="3-面试安排及回应"><a href="#3-面试安排及回应" class="headerlink" title="3. 面试安排及回应"></a>3. 面试安排及回应</h4><p>&#8195;&#8195;团队目前比较小，于是领导干起了HR的活，因为还有后端前端的招聘，所以面试安排统一由领导来统筹，亲自给筛选出来的简历人员打电话邀请面试，赞一波领导。然而，那些没来参加面试而又没有通知我们的朋友们，不知道你们是怎么想的，答应的好好的，就算不来，也许你的临时日程和我们的安排冲突了，也许你有了更好的选择了，都没关系，来个电话或发个消息稍加说明，我们都能理解，我会给你安排新的时间或祝你新工作愉快，未来有机会再合作。信誉在哪？换位思考一下，我不知道，朋友，你还会不会这么做。与人方便即是与己方便。</p><h4 id="4-面试"><a href="#4-面试" class="headerlink" title="4. 面试"></a>4. 面试</h4><p>&#8195;&#8195;对于面试，想说多一点，特别是技术点</p><h6 id="Framework方向-1"><a href="#Framework方向-1" class="headerlink" title="Framework方向"></a>Framework方向</h6><p>&#8195;&#8195;这个方向的内容如果要问深度的那就要多深有多深了，鉴于收到的简历和来面试的人很少，我把条件放宽了许多，尽量从靠近app层的知识面入手提问。</p><ol><li>ART、Dalvik和JVM的关系及区别是什么？这是道送分题，并不是真的要说出它们的深度区别，但如果你不知道ART是什么，我觉得你不够关注行业发展，靠这个平台吃饭，不关心它，怎么都说不过去。</li><li>例举一下Android系统级服务，在App层一般都用过哪些？如何实现一个自定义的系统级服务？渐进式的问题，后边的有难度，如果没有Framework定制经验或没有研读过系统源码真的不好回答了。</li><li>Binder机制。难，基本个大概的概念也没有多少个人说的全的。</li><li>Launcher的实现。并非只有manifest里的launcher配置，其实要是能回答PackageManager、ActivityManager对应用包的管理和应用进程的管理，会有加分，因为有了这些，才算是个基本能用的Launcher。</li><li>系统级app和第三方应用级app分别在什么目录下？一个第三方的app能否直接放到系统级app目录下而又能正常运行？纯经验题，如果没倒腾过ROM，基本回答没戏了。</li><li>能不能单独编译一个系统级应用？ROM编译环境配置及编译脚本题。</li><li>JNI，共享库和静态库的区别和使用场景，JNI中C/C++和Java相互调用各自使用的机制是什么？偏app方向的题了。</li><li>如何限制第三方应用安装？</li></ol><h6 id="App方向-1"><a href="#App方向-1" class="headerlink" title="App方向"></a>App方向</h6><p>&#8195;&#8195;Android高速发展了快十年时间，平台软件开发现在已经到了各种框架、轮子满天飞的时代了，给应用软件的开发带来了极大的便利，我也在用别人的框架和轮子。但我不太喜欢在面试中听到“这xxx功能用框架实现就好了啊”。我们的职位需求明确了两年以上的工作经验，如果你这两年了还只会用框架而又对框架说不出个一二三，那是不是不那么对劲？更别说张口闭口就百度一下了，我还会谷歌呢。相信现在面试的基本也都刷过那么几套面试题、几本xxx宝典，但一些经验并不能靠刷题能刷出来或者能理解牢靠的，所以，这方向的面试我喜欢问细一点的问题。</p><ol><li>Activity建立在哪些窗口组件之上？顺带涉及View的事件传递问题。</li><li>什么情况下，Activity的onNewInstent()方法会执行？Activity的启动模式相关。</li><li>Activity A使用startForResult启动Activity B，B什么都不做并返回A，A中的onActivityResult回调是否会执行？</li><li>Fragment能否不依赖于Activity存在？简析一下Fragment的栈管理。</li><li>能否将一个Activity放到系统的最近任务列表里，独立于宿主app任务卡之外？</li><li>对于同一个Service，在被start启动之后还能不能被bind？</li><li>Service有哪些派生类？这些派生类的使用场景是什么？</li><li>Service与其它组件之间的通信实现方式有哪些？</li><li>View的post(Runnable r)方法里，r会带来一个新的线程吗？多线程相关。</li><li>在非UI线程中使用Handler需要注意哪些问题？</li><li>自定义View时有哪些重要的方法，它们的作用及执行顺序是怎样的？</li><li>如何单独对ListView上的一个item进行更新？</li><li>简析一下大图片的加载处理。</li><li>设计师只给了一套1280*800的UI图标注，如何进行其它分辨率尺寸屏幕的适配？</li><li>6.0系统新权限机制的解决方案。</li></ol><p>&#8195;&#8195;你们精通的开源框架，问题来了</p><ol><li>EventBus的机制是什么？和Handler的区别怎样？</li><li>RxJava的机制是什么？</li><li>Butterknife的机制是什么？</li><li>Okhttp是基于HTTP连接还是Socket连接？</li><li>例举一种ORM框架，说说它的优缺点。</li></ol><p>&#8195;&#8195;如果你写着精通各种框架，而上面的问题又回答不上来或者模棱两可含糊不清，只一个劲的说这些框架很方便你用的非常遛，那我认为你和我精通的没什么区别，我精通Windows, Mac, Linux系统电脑的开关机，还精通C/C++, Java, PHP, Python, Ruby等的书写。<br>&#8195;&#8195;就算框架横飞的今天，Android应用开发还是离不开基础四大组件、线程进程间通信、View处理(UI、各种事件)、数据存储消费、网络通信、平台特性碎片化适配等这些基础的原理，框架也都围绕着这些模块来建造，万变不离其宗，知其然也要知其所以然。<br>&#8195;&#8195;题目还有很多，比如以上还未列出Java部分的题，都不算什么太高明的面试题，不能全部例举了，不同的人根据不同的经验及具体项目进行提问，一般面试过程前15分钟即可分辨一个面试人员能否达到符合条件需求，所以，如何在这个时间段内最大限度的表现自己的能力很重要。</p><h4 id="5-面试评估"><a href="#5-面试评估" class="headerlink" title="5. 面试评估"></a>5. 面试评估</h4><p>&#8195;&#8195;评估的因素其实会有很多，临场发挥因素，抖腿、眼神飘忽、回答声音低小、遇难题岔开其它话题等，都是不好的临场表现。技术面的方向及深度因素，术业有专攻，面试题答不上来不代表就什么都不行，面试官也有自己的业务方向考量。这里，还想说一点是，有些朋友过来像是纯粹为了面试而面试，并不关心公司是做什么的，我们有官网，招聘启事上也有相关说明，然而问起时却一头雾水，或者完全不知道公司的业务和产品，也是比较尴尬了，没有用心准备一个面试，明显会被减分。即便真的不关心以后要做什么，也总得知道一下想加入的公司大概是怎样的，要不，这简历投递的意义是什么？</p><h4 id="6-面试调整"><a href="#6-面试调整" class="headerlink" title="6. 面试调整"></a>6. 面试调整</h4><p>&#8195;&#8195;我们面试基本有两轮，过了我的技术面，领导会接着再面，两面都过了才有可能成为以后共同的伙伴，所以，我也会倾听领导的面试反馈，调整我的面试要求和尺度，毕竟新伙伴是给整个团队找的，尽量能选到与团队气质符合的伙伴，所以，不光是技术面，更是综合面的考量。倾听反馈，做好下一次面试，节省领导的时间，也是节省自己的时间。</p><h4 id="7-面试总结"><a href="#7-面试总结" class="headerlink" title="7. 面试总结"></a>7. 面试总结</h4><p>&#8195;&#8195;以上，是这段时间对面试的一些拙见，无所谓干货，纯个人感想，找一份满意的工作不容易，找一个对味的伙伴不容易，且面且珍惜。有一个Framework方向的小伙感觉挺可惜的，做Android智能手表系统级软件定制两年时间，一直有机会接触Framework层，但上边的那些基础题都没有答到点上，问他为什么会这样，他感慨太忙了，基本只是在做老板给他安排的那些重复性的软件移植适配工作，Framework有其它同事负责，他就没什么关注了，如今出来了可就不一定那么好的机会再去研究了。小伙子人很谦诚，如果我们现在是大公司，可能我会选他，可以培养，可眼下，只好放弃了，祝愿他接下来找到合适的机会。忙是个客观理由，不是个主观借口。眼界的开阔不应该羁绊于踌躇的当下。所以，标榜“太忙了，顾不上学习新东西或其它东西”、“那些东西只有用到的时候才去搜索找方案”的朋友，好好准备，再出发吧，希望你不只活在搜索引擎里。<br>&#8195;&#8195;我其实也挺浮躁的，为了尽快招到帮手，一天多则可能会参加主持六七场面试，对精力是很大的消耗，会在某一些场次中出现一些毛躁的内心情绪而影响正常的提问评估。面对面的你和我，折射了一个行业的现状。<br>&#8195;&#8195;我也有自己的目标，不久的未来，就会离开这个城市，投身于新的环境，可能意味着要从零开始，也将会由面试官变成被面试者，接受别人的考察评判，要怀着敬畏的心。<br>&#8195;&#8195;这篇文章，献给我自己，如果你正在找工作赶着面试或者正在面试别人，看到这篇文章，能提不同的意见，也是最好不过。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自SegmentFault &lt;a href=&quot;https://segmentfault.com/a/1190000008682444&quot; title=&quot;我眼中的面试&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我自己的文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;#8195;&amp;#8195;最近在给公司招Android开发人员，面向两个方向，Framework和App，近一个月的时间以来，总体特点是Framework方向近乎无人问津，而App方向则简历“泛滥”，想招个靠谱的伙伴真的不容易。最近的工作时常被频繁的面试安排打断，面试之余，想总结一下这段时间的感受。尽量从面试流程的各个环节都有一些涉及，当作回忆也好，经验也罢。当作给自己的沉淀吧。&lt;/p&gt;
&lt;h4 id=&quot;1-简历的投递&quot;&gt;&lt;a href=&quot;#1-简历的投递&quot; class=&quot;headerlink&quot; title=&quot;1. 简历的投递&quot;&gt;&lt;/a&gt;1. 简历的投递&lt;/h4&gt;&lt;h6 id=&quot;Framework方向&quot;&gt;&lt;a href=&quot;#Framework方向&quot; class=&quot;headerlink&quot; title=&quot;Framework方向&quot;&gt;&lt;/a&gt;Framework方向&lt;/h6&gt;&lt;p&gt;&amp;#8195;&amp;#8195;基本没有“正规军”出现，这也在我的意料之中，这个方向的人材稀缺，基本都待在大厂里不出来，因为对于系统级别的定制化改造真的是“搞事情”，资源的投入是巨大的，大厂都不一定搞得好的东西，何况对于一个像我们这样的小作坊呢。因为也不是紧急的需要，所以和领导确定的方案是花多一点的时间，放长线，广撒网，另外，利用人脉关系从大厂争取捞人。&lt;/p&gt;
&lt;h6 id=&quot;App方向&quot;&gt;&lt;a href=&quot;#App方向&quot; class=&quot;headerlink&quot; title=&quot;App方向&quot;&gt;&lt;/a&gt;App方向&lt;/h6&gt;&lt;p&gt;&amp;#8195;&amp;#8195;不得不先提一个小插曲，根据业务的进展，先放出的是Framework方向的岗位招聘，每天收到的简历寥寥无几，领导(领导不是很懂Android)问我，Android就这点人？我笑而不语，领导你等着。App岗位一开放，每天数倍的简历压过来，领导没再说什么了，之前和我一起审简历的工作也不参与了。&lt;br&gt;&amp;#8195;&amp;#8195;两个印象，一个是现在是90后的世界了，另一个是女生们多了，这算是广大男同胞们的福音吗？&lt;/p&gt;
&lt;h4 id=&quot;2-简历的筛选&quot;&gt;&lt;a href=&quot;#2-简历的筛选&quot; class=&quot;headerlink&quot; title=&quot;2. 简历的筛选&quot;&gt;&lt;/a&gt;2. 简历的筛选&lt;/h4&gt;&lt;p&gt;&amp;#8195;&amp;#8195;大部分的简历还是那个老生常谈的问题，太千篇一律了，让人看了提不起兴趣的那种，顺带的水分也就不提了，各种精通～可能大家心里都有数。&lt;/p&gt;
&lt;h6 id=&quot;太“简明”的简历会被刷&quot;&gt;&lt;a href=&quot;#太“简明”的简历会被刷&quot; class=&quot;headerlink&quot; title=&quot;太“简明”的简历会被刷&quot;&gt;&lt;/a&gt;太“简明”的简历会被刷&lt;/h6&gt;&lt;p&gt;&amp;#8195;&amp;#8195;简明到只有各种荣誉证书各种精通，却没有具体的项目介绍，想简明可以贴个作品链接啊，那些证书、精通的我们真的不太在乎，我们只希望能多了解一些你的工作经历，当然我们真的希望你能精通。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://chuyao.github.io/categories/Tech/"/>
    
    
      <category term="Interview" scheme="https://chuyao.github.io/tags/Interview/"/>
    
      <category term="Android" scheme="https://chuyao.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
